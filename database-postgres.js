import pg from 'pg';
const { Pool } = pg;

export class PostgresDatabaseManager {
  constructor(connectionString) {
    this.pool = new Pool({
      connectionString,
      max: 25,                          // Slightly more connections for high concurrency
      min: 5,                           // Keep minimum connections ready
      idleTimeoutMillis: 60000,         // Keep idle connections longer (1 min)
      connectionTimeoutMillis: 5000,    // Fail fast on connection issues
      statement_timeout: 10000,         // 10s max query time
      query_timeout: 10000,
      keepAlive: true,
      keepAliveInitialDelayMillis: 5000,
      allowExitOnIdle: false,
    });
    this.pool.on('error', (err) => console.error('[DB] Pool error:', err));
    this._queryCount = 0;
    this._slowQueryThreshold = 3000;
    this._cache = {
      playersSlim: { data: null, ts: 0, ttl: 30000 },      // 30 seconds - bulk API uses this
      trackRecords: { data: null, ts: 0, ttl: 60000 },     // 60 seconds - records don't change often
      trackList: { data: null, ts: 0, ttl: 120000 },       // 2 minutes - track list rarely changes
      totalPlayersCount: { data: null, ts: 0, ttl: 120000 }, // 2 minutes - total count for pagination
      totalCounts: { data: null, ts: 0, ttl: 60000 },        // 1 minute - stats counts for homepage
      playerAvatars: { data: null, ts: 0, ttl: 120000 },      // 2 minutes - avatar map for all players
      topMMR: { data: null, ts: 0, ttl: 60000 },           // 60 seconds - leaderboards update slowly
      topSR: { data: null, ts: 0, ttl: 60000 },            // 60 seconds - leaderboards update slowly
      sessionsCount: { data: null, ts: 0, ttl: 120000 },   // 2 minutes - total count rarely matters live
      recentSessions: { data: null, ts: 0, ttl: 15000 },   // 15 seconds - matches polling interval
      totalLapsCount: { data: null, ts: 0, ttl: 120000 },  // 2 minutes - total count rarely matters live
      mostActiveTrack: { data: null, ts: 0, ttl: 120000 }, // 2 minutes
    };
  }

  async _cached(key, fn) {
    const c = this._cache[key];
    const now = Date.now();
    if (c?.data && (now - c.ts) < c.ttl) return c.data;
    const result = await fn();
    if (c) { c.data = result; c.ts = now; }
    return result;
  }

  _invalidate(key) {
    if (this._cache[key]) { this._cache[key].data = null; this._cache[key].ts = 0; }
  }

  async initializeTables() {
    const client = await this.pool.connect();
    try {
      await client.query(`
        CREATE TABLE IF NOT EXISTS players (
          guid TEXT PRIMARY KEY, "displayName" TEXT NOT NULL, "displayNameLower" TEXT NOT NULL,
          mmr INTEGER DEFAULT 1000, "safetyRating" REAL DEFAULT 0.5, "totalRaces" INTEGER DEFAULT 0,
          wins INTEGER DEFAULT 0, podiums INTEGER DEFAULT 0, holeshots INTEGER DEFAULT 0,
          "raceNumber" INTEGER DEFAULT 0, "bikeName" TEXT, "currentServer" TEXT, "currentTrack" TEXT,
          "lastSeen" BIGINT, "firstSeen" BIGINT, "autoGenerated" BOOLEAN DEFAULT FALSE,
          "updatedAt" BIGINT, "isBanned" BOOLEAN DEFAULT FALSE, "banReason" TEXT, "banExpiry" BIGINT,
          notes TEXT, "steamAvatarUrl" TEXT, "steamAvatarUpdated" BIGINT, "totalPlaytime" BIGINT DEFAULT 0,
          "underInvestigation" BOOLEAN DEFAULT FALSE, "investigationReason" TEXT, "investigationBy" TEXT,
          "investigationDate" BIGINT, "frozenMMR" INTEGER
        );
        CREATE INDEX IF NOT EXISTS idx_players_mmr ON players(mmr DESC);
        CREATE INDEX IF NOT EXISTS idx_players_sr ON players("safetyRating" DESC);
        CREATE INDEX IF NOT EXISTS idx_players_lastseen ON players("lastSeen" DESC);
        CREATE INDEX IF NOT EXISTS idx_players_namelower ON players("displayNameLower");
      `);
      await client.query(`
        CREATE TABLE IF NOT EXISTS sessions (
          id TEXT PRIMARY KEY, "serverId" TEXT NOT NULL, "serverName" TEXT NOT NULL,
          "trackName" TEXT NOT NULL, "eventName" TEXT DEFAULT '', "sessionType" TEXT DEFAULT 'session',
          "currentSessionPhase" TEXT DEFAULT 'warmup', "sessionState" TEXT DEFAULT 'WAITING',
          "weatherConditions" TEXT DEFAULT 'Clear', "airTemperature" REAL DEFAULT 0,
          "trackLength" REAL DEFAULT 0, "startTime" BIGINT, "endTime" BIGINT,
          "warmupResults" JSONB DEFAULT '[]'::jsonb, "raceResults" JSONB DEFAULT '[]'::jsonb,
          "totalEntries" INTEGER DEFAULT 0, "hasFinished" BOOLEAN DEFAULT FALSE,
          "raceFinalized" BOOLEAN DEFAULT FALSE, "isActive" BOOLEAN DEFAULT TRUE, "createdAt" BIGINT
        );
        CREATE INDEX IF NOT EXISTS idx_sessions_created ON sessions("createdAt" DESC);
        CREATE INDEX IF NOT EXISTS idx_sessions_active ON sessions("isActive") WHERE "isActive" = TRUE;
        CREATE INDEX IF NOT EXISTS idx_sessions_finalized ON sessions("raceFinalized", "totalEntries", "startTime" DESC) WHERE "raceFinalized" = TRUE AND "totalEntries" > 0;
        CREATE INDEX IF NOT EXISTS idx_sessions_starttime ON sessions("startTime" DESC);
      `);
      await client.query(`
        CREATE TABLE IF NOT EXISTS player_sessions (
          "playerGuid" TEXT NOT NULL, "sessionId" TEXT NOT NULL, position INTEGER DEFAULT 0,
          "bestLapTime" REAL DEFAULT 0, "totalLaps" INTEGER DEFAULT 0, "didFinish" BOOLEAN DEFAULT FALSE,
          "mmrChange" INTEGER DEFAULT 0, "srChange" REAL DEFAULT 0, PRIMARY KEY ("playerGuid", "sessionId")
        );
      `);
      await client.query(`
        CREATE TABLE IF NOT EXISTS track_records (
          id TEXT PRIMARY KEY, "playerGuid" TEXT NOT NULL, "playerName" TEXT NOT NULL,
          "trackName" TEXT NOT NULL, "lapTime" REAL NOT NULL, "bikeName" TEXT, "bikeCategory" TEXT,
          "serverName" TEXT DEFAULT '', "sessionId" TEXT, "sessionType" TEXT DEFAULT 'live', "setAt" BIGINT
        );
        CREATE INDEX IF NOT EXISTS idx_track_records_track ON track_records("trackName", "lapTime" ASC);
        CREATE INDEX IF NOT EXISTS idx_track_records_player ON track_records("playerGuid");
      `);
      await client.query(`
        CREATE TABLE IF NOT EXISTS contacts (
          id TEXT PRIMARY KEY, "sessionId" TEXT NOT NULL, time REAL NOT NULL,
          "playerGuid1" TEXT, "playerName1" TEXT, "raceNumber1" INTEGER,
          "playerGuid2" TEXT, "playerName2" TEXT, "raceNumber2" INTEGER,
          "isWallContact" BOOLEAN DEFAULT FALSE, "relativeImpactVelocity" REAL, "createdAt" BIGINT
        );
      `);
      await client.query(`
        CREATE TABLE IF NOT EXISTS holeshots (
          id TEXT PRIMARY KEY, "sessionId" TEXT NOT NULL, "playerGuid" TEXT NOT NULL,
          "playerName" TEXT NOT NULL, "raceNumber" INTEGER DEFAULT 0, "holeshotTime" REAL NOT NULL,
          "trackName" TEXT, "createdAt" BIGINT
        );
      `);
      await client.query(`
        CREATE TABLE IF NOT EXISTS leader_election (
          id TEXT PRIMARY KEY DEFAULT 'primary', machine_id TEXT NOT NULL,
          last_heartbeat BIGINT NOT NULL, acquired_at BIGINT NOT NULL
        );
      `);
      await client.query(`
        CREATE TABLE IF NOT EXISTS ban_history (
          id TEXT PRIMARY KEY, "playerGuid" TEXT NOT NULL, "playerName" TEXT NOT NULL,
          action TEXT NOT NULL, reason TEXT, duration INTEGER, "durationType" TEXT,
          "isGlobal" BOOLEAN DEFAULT FALSE, "isPermanent" BOOLEAN DEFAULT FALSE,
          "expiresAt" BIGINT, "performedBy" TEXT DEFAULT 'System', "sourceManager" TEXT,
          "serverName" TEXT, "evidenceUrl" TEXT, "createdAt" BIGINT NOT NULL
        );
        CREATE INDEX IF NOT EXISTS idx_ban_history_player ON ban_history("playerGuid");
        CREATE INDEX IF NOT EXISTS idx_ban_history_created ON ban_history("createdAt" DESC);
      `);
      await client.query(`
        CREATE TABLE IF NOT EXISTS ban_appeals (
          id TEXT PRIMARY KEY, "appealIndex" SERIAL, "playerGuid" TEXT NOT NULL,
          "playerName" TEXT NOT NULL, "userId" TEXT NOT NULL, "banReason" TEXT, "banDate" BIGINT,
          "banExpiry" BIGINT, "isPermanent" BOOLEAN DEFAULT FALSE, "serverName" TEXT,
          "isGlobal" BOOLEAN DEFAULT FALSE, "appealReason" TEXT NOT NULL, "additionalInfo" TEXT,
          "videoUrl" TEXT, status TEXT DEFAULT 'open', "claimedBy" TEXT, "claimedByGuid" TEXT,
          "claimedAt" BIGINT, "resolvedBy" TEXT, "resolvedByGuid" TEXT, "resolvedAt" BIGINT,
          resolution TEXT, "cooldownUntil" BIGINT, "createdAt" BIGINT NOT NULL, "updatedAt" BIGINT
        );
        CREATE INDEX IF NOT EXISTS idx_ban_appeals_user ON ban_appeals("userId");
        CREATE INDEX IF NOT EXISTS idx_ban_appeals_player ON ban_appeals("playerGuid");
        CREATE INDEX IF NOT EXISTS idx_ban_appeals_status ON ban_appeals(status);
        CREATE INDEX IF NOT EXISTS idx_ban_appeals_created ON ban_appeals("createdAt" DESC);
      `);
      await client.query(`
        CREATE TABLE IF NOT EXISTS player_reports (
          id TEXT PRIMARY KEY, "reportIndex" SERIAL, "reporterGuid" TEXT NOT NULL,
          "reporterName" TEXT NOT NULL, "reporterUserId" TEXT NOT NULL, "offenderGuid" TEXT NOT NULL,
          "offenderName" TEXT NOT NULL, "serverName" TEXT, reason TEXT NOT NULL, description TEXT NOT NULL,
          "videoUrl" TEXT NOT NULL, status TEXT DEFAULT 'open', "claimedBy" TEXT, "claimedByGuid" TEXT,
          "claimedAt" BIGINT, "resolvedBy" TEXT, "resolvedByGuid" TEXT, "resolvedAt" BIGINT,
          resolution TEXT, "actionTaken" TEXT, "createdAt" BIGINT NOT NULL, "updatedAt" BIGINT
        );
        CREATE INDEX IF NOT EXISTS idx_player_reports_user ON player_reports("reporterUserId");
        CREATE INDEX IF NOT EXISTS idx_player_reports_offender ON player_reports("offenderGuid");
        CREATE INDEX IF NOT EXISTS idx_player_reports_status ON player_reports(status);
        CREATE INDEX IF NOT EXISTS idx_player_reports_created ON player_reports("createdAt" DESC);
      `);
      await client.query(`
        CREATE TABLE IF NOT EXISTS notifications (
          id TEXT PRIMARY KEY, "userId" TEXT NOT NULL, type TEXT NOT NULL, title TEXT NOT NULL,
          message TEXT NOT NULL, link TEXT, read BOOLEAN DEFAULT FALSE, "relatedId" TEXT, "createdAt" BIGINT NOT NULL
        );
        CREATE INDEX IF NOT EXISTS idx_notifications_user ON notifications("userId");
        CREATE INDEX IF NOT EXISTS idx_notifications_read ON notifications("userId", read) WHERE read = FALSE;
        CREATE INDEX IF NOT EXISTS idx_notifications_created ON notifications("createdAt" DESC);
        CREATE INDEX IF NOT EXISTS idx_notifications_related ON notifications("relatedId");
      `);
      await client.query(`
        CREATE TABLE IF NOT EXISTS player_warnings (
          id TEXT PRIMARY KEY, "playerGuid" TEXT NOT NULL, "playerName" TEXT NOT NULL,
          reason TEXT NOT NULL, "warnedBy" TEXT NOT NULL, "warnedByGuid" TEXT, "reportId" TEXT,
          "createdAt" BIGINT NOT NULL, acknowledged BOOLEAN DEFAULT FALSE, "acknowledgedAt" BIGINT
        );
        CREATE INDEX IF NOT EXISTS idx_player_warnings_player ON player_warnings("playerGuid");
        CREATE INDEX IF NOT EXISTS idx_player_warnings_created ON player_warnings("createdAt" DESC);
      `);
      await client.query(`
        CREATE TABLE IF NOT EXISTS announcements (
          id TEXT PRIMARY KEY, title TEXT NOT NULL, message TEXT NOT NULL, type TEXT DEFAULT 'info',
          active BOOLEAN DEFAULT TRUE, "createdBy" TEXT NOT NULL, "createdByName" TEXT,
          "createdAt" BIGINT NOT NULL, "updatedAt" BIGINT, "expiresAt" BIGINT
        );
        CREATE INDEX IF NOT EXISTS idx_announcements_active ON announcements(active) WHERE active = TRUE;
        CREATE INDEX IF NOT EXISTS idx_announcements_created ON announcements("createdAt" DESC);
      `);
      await client.query(`
        CREATE TABLE IF NOT EXISTS polls (
          id TEXT PRIMARY KEY, question TEXT NOT NULL, options JSONB NOT NULL DEFAULT '[]',
          votes JSONB NOT NULL DEFAULT '{}', active BOOLEAN DEFAULT TRUE,
          "createdBy" TEXT NOT NULL, "createdByName" TEXT,
          "createdAt" BIGINT NOT NULL, "expiresAt" BIGINT NOT NULL,
          "showResults" BOOLEAN DEFAULT FALSE
        );
        CREATE INDEX IF NOT EXISTS idx_polls_active ON polls(active) WHERE active = TRUE;
        CREATE INDEX IF NOT EXISTS idx_polls_expires ON polls("expiresAt");
      `);
      await client.query(`
        CREATE TABLE IF NOT EXISTS feature_requests (
          id TEXT PRIMARY KEY, "requestIndex" SERIAL, title TEXT NOT NULL, description TEXT NOT NULL,
          type TEXT DEFAULT 'feature', status TEXT DEFAULT 'pending', "submittedBy" TEXT NOT NULL,
          "submittedByName" TEXT NOT NULL, "submittedByGuid" TEXT, "developerComment" TEXT,
          upvotes TEXT[] DEFAULT '{}', downvotes TEXT[] DEFAULT '{}', "createdAt" BIGINT NOT NULL, "updatedAt" BIGINT
        );
        CREATE INDEX IF NOT EXISTS idx_feature_requests_status ON feature_requests(status);
        CREATE INDEX IF NOT EXISTS idx_feature_requests_created ON feature_requests("createdAt" DESC);
      `);
      await client.query(`
        CREATE TABLE IF NOT EXISTS support_tickets (
          id TEXT PRIMARY KEY, "userId" TEXT NOT NULL, "userEmail" TEXT, "reporterGuid" TEXT,
          "reporterName" TEXT, "issueType" TEXT NOT NULL, subject TEXT NOT NULL, description TEXT NOT NULL,
          status TEXT DEFAULT 'pending', resolution TEXT, "resolvedBy" TEXT, "resolvedByGuid" TEXT,
          "resolvedAt" BIGINT, "createdAt" BIGINT NOT NULL, "updatedAt" BIGINT
        );
        CREATE INDEX IF NOT EXISTS idx_support_tickets_user ON support_tickets("userId");
        CREATE INDEX IF NOT EXISTS idx_support_tickets_status ON support_tickets(status);
        CREATE INDEX IF NOT EXISTS idx_support_tickets_created ON support_tickets("createdAt" DESC);
      `);
      await client.query(`
        CREATE TABLE IF NOT EXISTS message_templates (
          id TEXT PRIMARY KEY DEFAULT 'default',
          "banPrivateMessageEnabled" BOOLEAN DEFAULT true, "banPrivateMessageTemplate" TEXT DEFAULT 'You have been banned for {duration}. Reason: {reason}',
          "banGlobalMessageEnabled" BOOLEAN DEFAULT true, "banGlobalMessageTemplate" TEXT DEFAULT '{name} has been banned for {duration}. Reason: {reason}',
          "unbanMessageEnabled" BOOLEAN DEFAULT true, "unbanMessageTemplate" TEXT DEFAULT '{name} has been unbanned',
          "warningMessageEnabled" BOOLEAN DEFAULT true, "warningMessageTemplate" TEXT DEFAULT 'WARNING: {reason}',
          "warningGlobalMessageEnabled" BOOLEAN DEFAULT true, "warningGlobalMessageTemplate" TEXT DEFAULT '{name} has received a warning: {reason}',
          "kickPrivateMessageEnabled" BOOLEAN DEFAULT true, "kickPrivateMessageTemplate" TEXT DEFAULT 'You have been kicked. Reason: {reason}',
          "kickGlobalMessageEnabled" BOOLEAN DEFAULT true, "kickGlobalMessageTemplate" TEXT DEFAULT '{name} has been kicked. Reason: {reason}',
          "updatedAt" BIGINT
        );
        INSERT INTO message_templates (id) VALUES ('default') ON CONFLICT (id) DO NOTHING;
      `);
      await client.query(`
        CREATE TABLE IF NOT EXISTS automated_messages (
          id TEXT PRIMARY KEY, message TEXT NOT NULL, "intervalMinutes" INTEGER NOT NULL DEFAULT 5,
          "isEnabled" BOOLEAN DEFAULT true, "isGlobal" BOOLEAN DEFAULT false, "serverId" TEXT,
          "serverName" TEXT, "lastSent" BIGINT, "createdAt" BIGINT NOT NULL, "updatedAt" BIGINT
        );
        CREATE INDEX IF NOT EXISTS idx_automated_messages_enabled ON automated_messages("isEnabled");
        CREATE INDEX IF NOT EXISTS idx_automated_messages_server ON automated_messages("serverId");
      `);
      await client.query(`
        CREATE TABLE IF NOT EXISTS donations (
          id TEXT PRIMARY KEY, "stripePaymentId" TEXT UNIQUE, "stripeCustomerId" TEXT,
          email TEXT, name TEXT, amount INTEGER NOT NULL, currency TEXT DEFAULT 'usd',
          status TEXT DEFAULT 'pending', message TEXT, "isAnonymous" BOOLEAN DEFAULT FALSE,
          "playerGuid" TEXT, "playerName" TEXT, "createdAt" BIGINT NOT NULL
        );
        CREATE INDEX IF NOT EXISTS idx_donations_created ON donations("createdAt" DESC);
        CREATE INDEX IF NOT EXISTS idx_donations_status ON donations(status);
        CREATE INDEX IF NOT EXISTS idx_donations_player ON donations("playerGuid");
      `);

      // PERFORMANCE INDEXES - Critical for 47k+ players, 2M+ laps
      await client.query(`
        -- Players: Composite index for optimized bulk query (lastSeen OR mmr OR totalRaces)
        CREATE INDEX IF NOT EXISTS idx_players_bulk_filter ON players("lastSeen" DESC, mmr DESC, "totalRaces" DESC);

        -- Players: For sorting in paginated queries
        CREATE INDEX IF NOT EXISTS idx_players_mmr_nulls ON players(mmr DESC NULLS LAST);
        CREATE INDEX IF NOT EXISTS idx_players_sr_nulls ON players("safetyRating" DESC NULLS LAST);
        CREATE INDEX IF NOT EXISTS idx_players_races_nulls ON players("totalRaces" DESC NULLS LAST);

        -- Track records: Composite for fast track leaderboards
        CREATE INDEX IF NOT EXISTS idx_track_records_track_time ON track_records("trackName", "lapTime" ASC);
        CREATE INDEX IF NOT EXISTS idx_track_records_player_track ON track_records("playerGuid", "trackName");

        -- Player sessions: For fast player history lookups
        CREATE INDEX IF NOT EXISTS idx_player_sessions_player ON player_sessions("playerGuid");
        CREATE INDEX IF NOT EXISTS idx_player_sessions_session ON player_sessions("sessionId");

        -- Sessions: For paginated queries
        CREATE INDEX IF NOT EXISTS idx_sessions_track ON sessions("trackName");
        CREATE INDEX IF NOT EXISTS idx_sessions_server ON sessions("serverId");
      `);
      console.log('[DB] Tables and performance indexes initialized');
    } finally { client.release(); }
  }

  async upsertPlayer(p) {
    const now = Date.now();
    const name = p.displayName || `Player_${p.guid.slice(-8)}`;
    await this.pool.query(`
      INSERT INTO players (guid, "displayName", "displayNameLower", mmr, "safetyRating", "totalRaces", wins, podiums, "raceNumber", "bikeName", "currentServer", "currentTrack", "lastSeen", "firstSeen", "autoGenerated", "updatedAt")
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)
      ON CONFLICT (guid) DO UPDATE SET "displayName" = EXCLUDED."displayName", "displayNameLower" = EXCLUDED."displayNameLower", "raceNumber" = EXCLUDED."raceNumber", "bikeName" = EXCLUDED."bikeName", "currentServer" = EXCLUDED."currentServer", "currentTrack" = EXCLUDED."currentTrack", "lastSeen" = EXCLUDED."lastSeen", "updatedAt" = EXCLUDED."updatedAt"
    `, [p.guid, name, name.toLowerCase(), p.mmr || 1000, p.safetyRating || 800, p.totalRaces || 0, p.wins || 0, p.podiums || 0, p.raceNumber || 0, p.bikeName || null, p.currentServer || null, p.currentTrack || null, p.lastSeen || now, p.firstSeen || now, p.autoGenerated || false, now]);
  }

  async batchUpsertPlayers(players, playtimeInc = 60000) {
    if (!players.length) return;
    const now = Date.now();
    const client = await this.pool.connect();
    try {
      await client.query('BEGIN');
      for (const p of players) {
        const name = p.displayName || `Player_${p.guid.slice(-8)}`;
        await client.query(`
          INSERT INTO players (guid, "displayName", "displayNameLower", mmr, "safetyRating", "totalRaces", wins, podiums, "raceNumber", "bikeName", "currentServer", "currentTrack", "lastSeen", "firstSeen", "autoGenerated", "updatedAt", "totalPlaytime")
          VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, 0)
          ON CONFLICT (guid) DO UPDATE SET "displayName" = EXCLUDED."displayName", "displayNameLower" = EXCLUDED."displayNameLower", "raceNumber" = EXCLUDED."raceNumber", "bikeName" = EXCLUDED."bikeName", "currentServer" = EXCLUDED."currentServer", "currentTrack" = EXCLUDED."currentTrack", "lastSeen" = EXCLUDED."lastSeen", "updatedAt" = EXCLUDED."updatedAt", "totalPlaytime" = COALESCE(players."totalPlaytime", 0) + $17
        `, [p.guid, name, name.toLowerCase(), p.mmr || 1000, p.safetyRating || 800, p.totalRaces || 0, p.wins || 0, p.podiums || 0, p.raceNumber || 0, p.bikeName || null, p.currentServer || null, p.currentTrack || null, p.lastSeen || now, p.firstSeen || now, p.autoGenerated || false, now, playtimeInc]);
      }
      await client.query('COMMIT');
      this._invalidate('playersSlim');
    } catch (err) { await client.query('ROLLBACK'); throw err; }
    finally { client.release(); }
  }

  async getPlayer(guid) {
    const result = await this.pool.query(`
      SELECT p.*, COALESCE(rc.count, 0) as "actualTotalRaces", COALESCE(wc.count, 0) as "actualWins", COALESCE(pc.count, 0) as "actualPodiums"
      FROM players p
      LEFT JOIN (SELECT ps."playerGuid", COUNT(*) as count FROM player_sessions ps INNER JOIN sessions s ON s.id = ps."sessionId" WHERE LOWER(s."sessionType") LIKE '%race%' GROUP BY ps."playerGuid") rc ON rc."playerGuid" = p.guid
      LEFT JOIN (SELECT ps."playerGuid", COUNT(*) as count FROM player_sessions ps INNER JOIN sessions s ON s.id = ps."sessionId" WHERE LOWER(s."sessionType") LIKE '%race%' AND ps.position = 1 GROUP BY ps."playerGuid") wc ON wc."playerGuid" = p.guid
      LEFT JOIN (SELECT ps."playerGuid", COUNT(*) as count FROM player_sessions ps INNER JOIN sessions s ON s.id = ps."sessionId" WHERE LOWER(s."sessionType") LIKE '%race%' AND ps.position <= 3 GROUP BY ps."playerGuid") pc ON pc."playerGuid" = p.guid
      WHERE p.guid = $1
    `, [guid]);
    if (!result.rows.length) return null;
    const row = result.rows[0];
    const player = this._rowToPlayer(row);
    player.totalRaces = parseInt(row.actualTotalRaces) || player.totalRaces;
    player.wins = parseInt(row.actualWins) || player.wins;
    player.podiums = parseInt(row.actualPodiums) || player.podiums;
    return player;
  }

  async getAllPlayers() {
    const result = await this.pool.query('SELECT * FROM players ORDER BY "lastSeen" DESC');
    return result.rows.map(r => this._rowToPlayer(r));
  }

  async getRecentPlayers(limit = 1000) {
    const result = await this.pool.query('SELECT * FROM players ORDER BY "lastSeen" DESC LIMIT $1', [limit]);
    return result.rows.map(r => this._rowToPlayer(r));
  }

  async searchPlayers(query, limit = 100) {
    const term = `%${query.toLowerCase()}%`;
    // Use subquery to get MMR rank for each matching player
    const result = await this.pool.query(`
      WITH ranked AS (
        SELECT *, ROW_NUMBER() OVER (ORDER BY mmr DESC) as mmr_rank
        FROM players
      )
      SELECT * FROM ranked
      WHERE "displayNameLower" LIKE $1 OR guid ILIKE $1
      ORDER BY mmr DESC
      LIMIT $2
    `, [term, limit]);
    return result.rows.map(r => ({ ...this._rowToPlayer(r), mmrRank: parseInt(r.mmr_rank) }));
  }

  async getTotalPlayersCount() {
    const result = await this.pool.query('SELECT COUNT(*) as count FROM players');
    return parseInt(result.rows[0].count);
  }

  async getBatchPlayers(guids) {
    if (!guids.length) return [];
    const ph = guids.map((_, i) => `$${i + 1}`).join(',');
    const result = await this.pool.query(`SELECT * FROM players WHERE guid IN (${ph})`, guids);
    return result.rows.map(r => this._rowToPlayer(r));
  }

  async getTopPlayersByMMR(limit = 100) {
    if (limit === 100) return this._cached('topMMR', async () => {
      const result = await this.pool.query('SELECT * FROM players ORDER BY mmr DESC LIMIT $1', [limit]);
      return result.rows.map(r => this._rowToPlayer(r));
    });
    const result = await this.pool.query('SELECT * FROM players ORDER BY mmr DESC LIMIT $1', [limit]);
    return result.rows.map(r => this._rowToPlayer(r));
  }

  async getTopPlayersBySR(limit = 100) {
    if (limit === 100) return this._cached('topSR', async () => {
      const result = await this.pool.query('SELECT * FROM players ORDER BY "safetyRating" DESC LIMIT $1', [limit]);
      return result.rows.map(r => this._rowToPlayer(r));
    });
    const result = await this.pool.query('SELECT * FROM players ORDER BY "safetyRating" DESC LIMIT $1', [limit]);
    return result.rows.map(r => this._rowToPlayer(r));
  }

  async updatePlayerMMR(guid, mmrChange, srChange, won = false, podium = false) {
    await this.pool.query(`UPDATE players SET mmr = GREATEST(0, mmr + $1), "safetyRating" = GREATEST(0.0, "safetyRating" + $2), "totalRaces" = "totalRaces" + 1, wins = wins + $3, podiums = podiums + $4, "updatedAt" = $5 WHERE guid = $6`, [mmrChange, srChange, won ? 1 : 0, podium ? 1 : 0, Date.now(), guid]);
  }

  async reduceSafetyRating(guid, reduction = 120) {
    await this.pool.query(`UPDATE players SET "safetyRating" = GREATEST(0.0, "safetyRating" - $1), "updatedAt" = $2 WHERE guid = $3`, [reduction, Date.now(), guid]);
    console.log(`[DB] SR reduced by ${reduction} for ${guid}`);
  }

  calculateMMRChanges(results) {
    const changes = [];
    const total = results.length;
    const holeshotWinner = results.filter(r => r.holeshotTime > 0).sort((a, b) => a.holeshotTime - b.holeshotTime)[0];
    const holeshotGuid = holeshotWinner?.playerGuid;
    if (total < 3) {
      for (let i = 0; i < results.length; i++) {
        changes.push({ playerGuid: results[i].playerGuid, mmrChange: 0, srChange: this._calcSR(results[i]), won: i === 0, podium: i < 3, gotHoleshot: results[i].playerGuid === holeshotGuid });
      }
      return changes;
    }
    let baseMMR = Math.pow(total, 0.70) * 2.4;
    if (total <= 5) baseMMR *= 0.6;
    const zeroPoint = Math.ceil(total * 0.55);
    for (let i = 0; i < results.length; i++) {
      const p = results[i];
      const pos = i + 1;
      let mmrChange = 0;
      const srChange = this._calcSR(p);
      if (pos < zeroPoint) {
        const factor = Math.pow((zeroPoint - pos) / Math.max(1, zeroPoint - 1), 1.2);
        mmrChange = Math.round(baseMMR * factor);
        if (total >= 10) { if (pos === 1) mmrChange += 3; if (pos === 2) mmrChange += 2; if (pos === 3) mmrChange += 1; }
      } else if (pos > zeroPoint) {
        const lossFactor = (pos - zeroPoint) / (total - zeroPoint);
        mmrChange = -Math.round((baseMMR * lossFactor) * 0.6);
      }
      changes.push({ playerGuid: p.playerGuid, mmrChange, srChange, won: pos === 1, podium: pos <= 3, gotHoleshot: p.playerGuid === holeshotGuid });
    }
    return changes;
  }

  _calcSR(p) {
    let sr = 3;
    const dnf = p.driverStatus === 'RET' || p.driverStatus === 'DNS' || p.driverStatus === 'DSQ';
    if (dnf) { console.log(`[SR] ${p.playerName}: DNF -12`); return -12; }
    const contacts = p.contacts || [];
    const laps = p.totalLaps || 1;
    let bikeContacts = 0;
    for (const c of contacts) {
      const spd = c.relative_impact_velocity || 0;
      const isBike = c.race_number_1 > 0 && c.race_number_2 > 0;
      if (isBike) { bikeContacts++; sr -= spd < 3 ? 1 : spd < 8 ? 4 : 8; }
      else { sr -= spd < 5 ? 0.5 : spd < 15 ? 1.5 : 2.5; }
    }
    const majors = contacts.filter(c => (c.relative_impact_velocity || 0) >= 5).length + bikeContacts;
    sr += Math.max(0, laps - majors) * 1.5;
    if (!contacts.length && laps >= 3) sr += 10;
    sr -= (p.invalidLaps || 0) * 2;
    const penalties = p.penalties || [];
    const cutting = penalties.filter(x => x.offence === 'CUTTING' || x.type === 'TIME');
    sr -= cutting.length * 3;
    sr -= cutting.reduce((s, x) => s + Math.floor((x.penalty_time || 0) / 5), 0);
    sr -= penalties.filter(x => x.offence === 'JUMPSTART').length * 10;
    if (contacts.length >= 10) sr -= (contacts.length - 10);
    sr = Math.max(-25, Math.min(20, sr));
    console.log(`[SR] ${p.playerName}: ${sr > 0 ? '+' : ''}${sr.toFixed(1)}`);
    return sr;
  }

  async batchUpdatePlayerMMR(changes) {
    if (!changes.length) return;
    const now = Date.now();
    const client = await this.pool.connect();
    try {
      await client.query('BEGIN');
      for (const c of changes) {
        await client.query(`UPDATE players SET mmr = GREATEST(0, mmr + $1), "safetyRating" = GREATEST(0.0, "safetyRating" + $2), "totalRaces" = "totalRaces" + 1, wins = wins + $3, podiums = podiums + $4, holeshots = holeshots + $5, "updatedAt" = $6 WHERE guid = $7`, [c.mmrChange, c.srChange, c.won ? 1 : 0, c.podium ? 1 : 0, c.gotHoleshot ? 1 : 0, now, c.playerGuid]);
      }
      await client.query('COMMIT');
      this._invalidate('playersSlim'); this._invalidate('topMMR'); this._invalidate('topSR');
    } catch (err) { await client.query('ROLLBACK'); throw err; }
    finally { client.release(); }
  }

  async investigatePlayer(guid, reason, admin) {
    const p = await this.getPlayer(guid);
    if (!p) throw new Error('Player not found');
    if (p.underInvestigation) throw new Error('Already under investigation');
    await this.pool.query(`UPDATE players SET "underInvestigation" = TRUE, "investigationReason" = $1, "investigationBy" = $2, "investigationDate" = $3, "frozenMMR" = mmr, mmr = 1, "updatedAt" = $3 WHERE guid = $4`, [reason, admin, Date.now(), guid]);
    this._invalidate('playersSlim'); this._invalidate('topMMR');
    return { originalMMR: p.mmr };
  }

  async restorePlayer(guid) {
    const p = await this.getPlayer(guid);
    if (!p) throw new Error('Player not found');
    if (!p.underInvestigation) throw new Error('Not under investigation');
    const mmr = p.frozenMMR || 1000;
    await this.pool.query(`UPDATE players SET "underInvestigation" = FALSE, "investigationReason" = NULL, "investigationBy" = NULL, "investigationDate" = NULL, mmr = $1, "frozenMMR" = NULL, "updatedAt" = $2 WHERE guid = $3`, [mmr, Date.now(), guid]);
    this._invalidate('playersSlim'); this._invalidate('topMMR');
    return { restoredMMR: mmr };
  }

  async getPlayersUnderInvestigation() {
    const result = await this.pool.query(`SELECT guid, "displayName", "investigationReason", "investigationBy", "investigationDate", "frozenMMR" FROM players WHERE "underInvestigation" = TRUE ORDER BY "investigationDate" DESC`);
    return result.rows;
  }

  async getPlayerSessions(guid, limit = 20) {
    const result = await this.pool.query(`SELECT s.*, ps.position, ps."bestLapTime", ps."totalLaps", ps."didFinish", ps."mmrChange", ps."srChange" FROM sessions s INNER JOIN player_sessions ps ON s.id = ps."sessionId" WHERE ps."playerGuid" = $1 ORDER BY s."createdAt" DESC LIMIT $2`, [guid, limit]);
    return result.rows.map(r => ({ ...this._rowToSession(r), playerPosition: r.position, playerBestLap: r.bestLapTime, playerLaps: r.totalLaps, playerFinished: r.didFinish, mmrChange: r.mmrChange, srChange: r.srChange }));
  }

  async addPlayerToSession(sessionId, guid, data) {
    await this.pool.query(`INSERT INTO player_sessions ("playerGuid", "sessionId", position, "bestLapTime", "totalLaps", "didFinish", "mmrChange", "srChange") VALUES ($1, $2, $3, $4, $5, $6, $7, $8) ON CONFLICT ("playerGuid", "sessionId") DO UPDATE SET position = EXCLUDED.position, "bestLapTime" = EXCLUDED."bestLapTime", "totalLaps" = EXCLUDED."totalLaps", "didFinish" = EXCLUDED."didFinish", "mmrChange" = EXCLUDED."mmrChange", "srChange" = EXCLUDED."srChange"`, [guid, sessionId, data.position || 0, data.bestLapTime || 0, data.totalLaps || 0, data.didFinish || false, data.mmrChange || 0, data.srChange || 0]);
  }

  async batchAddPlayersToSession(sessionId, players) {
    if (!players.length) return;
    const client = await this.pool.connect();
    try {
      await client.query('BEGIN');
      for (const p of players) {
        await client.query(`INSERT INTO player_sessions ("playerGuid", "sessionId", position, "bestLapTime", "totalLaps", "didFinish", "mmrChange", "srChange") VALUES ($1, $2, $3, $4, $5, $6, $7, $8) ON CONFLICT ("playerGuid", "sessionId") DO UPDATE SET position = EXCLUDED.position, "bestLapTime" = EXCLUDED."bestLapTime", "totalLaps" = EXCLUDED."totalLaps", "didFinish" = EXCLUDED."didFinish", "mmrChange" = EXCLUDED."mmrChange", "srChange" = EXCLUDED."srChange"`, [p.playerGuid, sessionId, p.position || 0, p.bestLapTime || 0, p.totalLaps || 0, p.didFinish || false, p.mmrChange || 0, p.srChange || 0]);
      }
      await client.query('COMMIT');
    } catch (err) { await client.query('ROLLBACK'); throw err; }
    finally { client.release(); }
  }

  _rowToPlayer(r) {
    return { guid: r.guid, displayName: r.displayName, mmr: r.mmr, safetyRating: r.safetyRating, totalRaces: r.totalRaces, wins: r.wins, podiums: r.podiums, holeshots: r.holeshots || 0, raceNumber: r.raceNumber, bikeName: r.bikeName, currentServer: r.currentServer, currentTrack: r.currentTrack, lastSeen: r.lastSeen ? parseInt(r.lastSeen) : null, firstSeen: r.firstSeen ? parseInt(r.firstSeen) : null, autoGenerated: r.autoGenerated, updatedAt: r.updatedAt ? parseInt(r.updatedAt) : null, isBanned: r.isBanned, banReason: r.banReason, banExpiry: r.banExpiry ? parseInt(r.banExpiry) : null, notes: r.notes, profileImageUrl: r.steamAvatarUrl || null, totalPlaytime: r.totalPlaytime ? parseInt(r.totalPlaytime) : 0, underInvestigation: r.underInvestigation || false, investigationReason: r.investigationReason, investigationBy: r.investigationBy, investigationDate: r.investigationDate ? parseInt(r.investigationDate) : null, frozenMMR: r.frozenMMR };
  }

  _rowToPlayerSlim(r) {
    return { guid: r.guid, displayName: r.displayName, mmr: r.mmr, safetyRating: r.safetyRating, totalRaces: r.totalRaces, wins: r.wins, podiums: r.podiums, holeshots: r.holeshots, lastSeen: r.lastSeen ? parseInt(r.lastSeen) : null, firstSeen: r.firstSeen ? parseInt(r.firstSeen) : null, currentServer: r.currentServer, profileImageUrl: r.steamAvatarUrl || null, totalPlaytime: r.totalPlaytime ? parseInt(r.totalPlaytime) : 0, underInvestigation: r.underInvestigation || false };
  }

  // For bulk API - limited data for fast homepage loading
  // Search uses searchPlayers() which queries ALL players
  async getAllPlayersSlim() {
    return this._cached('playersSlim', async () => {
      // Only recent/active players for bulk - search API handles finding anyone
      const result = await this.pool.query(`
        SELECT guid, "displayName", mmr, "safetyRating", "totalRaces", wins, podiums, holeshots,
               "lastSeen", "firstSeen", "currentServer", "steamAvatarUrl", "totalPlaytime", "underInvestigation"
        FROM players
        WHERE "lastSeen" > $1 OR mmr > 1100 OR "totalRaces" > 5
        ORDER BY "lastSeen" DESC
        LIMIT 2000
      `, [Date.now() - 30 * 24 * 60 * 60 * 1000]);
      return result.rows.map(r => this._rowToPlayerSlim(r));
    });
  }

  // Paginated players - for browsing ALL 47k+ players with pagination
  async getPlayersPaginated(page = 1, limit = 50, sortBy = 'lastSeen', sortDir = 'DESC') {
    const validSorts = ['lastSeen', 'mmr', 'safetyRating', 'totalRaces', 'displayName'];
    const sort = validSorts.includes(sortBy) ? sortBy : 'lastSeen';
    const dir = sortDir.toUpperCase() === 'ASC' ? 'ASC' : 'DESC';
    const offset = (page - 1) * limit;

    const [players, countResult] = await Promise.all([
      this.pool.query(`
        SELECT guid, "displayName", mmr, "safetyRating", "totalRaces", wins, podiums, holeshots,
               "lastSeen", "firstSeen", "currentServer", "steamAvatarUrl", "totalPlaytime"
        FROM players
        ORDER BY "${sort}" ${dir} NULLS LAST
        LIMIT $1 OFFSET $2
      `, [limit, offset]),
      this._cached('totalPlayersCount', () => this.pool.query('SELECT COUNT(*) FROM players').then(r => parseInt(r.rows[0].count)))
    ]);

    return {
      players: players.rows.map(r => this._rowToPlayerSlim(r)),
      total: countResult,
      page,
      totalPages: Math.ceil(countResult / limit)
    };
  }

  async updatePlayerSteamAvatar(guid, url) { await this.pool.query(`UPDATE players SET "steamAvatarUrl" = $1, "steamAvatarUpdated" = $2 WHERE guid = $3`, [url, Date.now(), guid]); }

  async batchUpdateSteamAvatars(map) {
    if (!Object.keys(map).length) return;
    const client = await this.pool.connect();
    try {
      await client.query('BEGIN');
      for (const [guid, url] of Object.entries(map)) await client.query(`UPDATE players SET "steamAvatarUrl" = $1, "steamAvatarUpdated" = $2 WHERE guid = $3`, [url, Date.now(), guid]);
      await client.query('COMMIT');
    } catch (err) { await client.query('ROLLBACK'); throw err; }
    finally { client.release(); }
  }

  async getPlayersNeedingAvatarSync(limit = 100) {
    const ago = Date.now() - 12 * 60 * 60 * 1000;
    const result = await this.pool.query(`SELECT guid FROM players WHERE "steamAvatarUrl" IS NULL OR "steamAvatarUpdated" IS NULL OR "steamAvatarUpdated" < $1 ORDER BY "lastSeen" DESC NULLS LAST LIMIT $2`, [ago, limit]);
    return result.rows.map(r => r.guid);
  }

  async createSession(s) {
    const id = s.id || `${s.serverId}_${Date.now()}`;
    const now = Date.now();
    await this.pool.query(`INSERT INTO sessions (id, "serverId", "serverName", "trackName", "eventName", "sessionType", "currentSessionPhase", "sessionState", "weatherConditions", "airTemperature", "trackLength", "startTime", "warmupResults", "raceResults", "totalEntries", "hasFinished", "raceFinalized", "isActive", "createdAt") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19)`, [id, s.serverId, s.serverName, s.trackName, s.eventName || '', s.sessionType || 'session', s.currentSessionPhase || 'warmup', s.sessionState || 'WAITING', s.weatherConditions || 'Clear', s.airTemperature || 0, s.trackLength || 0, s.startTime || now, JSON.stringify(s.warmupResults || []), JSON.stringify(s.raceResults || []), s.totalEntries || 0, s.hasFinished || false, s.raceFinalized || false, s.isActive !== false, now]);
    return id;
  }

  async updateSession(id, u) {
    const parts = [], vals = [];
    let n = 1;
    if (u.warmupResults !== undefined) { parts.push(`"warmupResults" = $${n++}`); vals.push(JSON.stringify(u.warmupResults)); }
    if (u.raceResults !== undefined) { parts.push(`"raceResults" = $${n++}`); vals.push(JSON.stringify(u.raceResults)); }
    if (u.hasFinished !== undefined) { parts.push(`"hasFinished" = $${n++}`); vals.push(u.hasFinished); }
    if (u.raceFinalized !== undefined) { parts.push(`"raceFinalized" = $${n++}`); vals.push(u.raceFinalized); }
    if (u.isActive !== undefined) { parts.push(`"isActive" = $${n++}`); vals.push(u.isActive); }
    if (u.endTime !== undefined) { parts.push(`"endTime" = $${n++}`); vals.push(u.endTime); }
    if (u.currentSessionPhase !== undefined) { parts.push(`"currentSessionPhase" = $${n++}`); vals.push(u.currentSessionPhase); }
    if (u.sessionState !== undefined) { parts.push(`"sessionState" = $${n++}`); vals.push(u.sessionState); }
    if (u.totalEntries !== undefined) { parts.push(`"totalEntries" = $${n++}`); vals.push(u.totalEntries); }
    if (u.trackName !== undefined) { parts.push(`"trackName" = $${n++}`); vals.push(u.trackName); }
    if (!parts.length) return;
    vals.push(id);
    await this.pool.query(`UPDATE sessions SET ${parts.join(', ')} WHERE id = $${n}`, vals);
    if (u.raceFinalized || u.hasFinished) { this._invalidate('recentSessions'); this._invalidate('sessionsCount'); this._invalidate('totalCounts'); }
  }

  async batchUpdateSessions(updates) {
    if (!updates.length) return;
    const client = await this.pool.connect();
    try {
      await client.query('BEGIN');
      for (const u of updates) await client.query(`UPDATE sessions SET "warmupResults" = $1, "totalEntries" = $2 WHERE id = $3`, [JSON.stringify(u.updates.warmupResults), u.updates.totalEntries, u.sessionId]);
      await client.query('COMMIT');
    } catch (err) { await client.query('ROLLBACK'); throw err; }
    finally { client.release(); }
  }

  async getRecentSessions(limit = 50) {
    const q = `(SELECT * FROM sessions WHERE "raceFinalized" = TRUE AND "totalEntries" > 0 ORDER BY "startTime" DESC LIMIT $1) UNION ALL (SELECT * FROM sessions WHERE "isActive" = TRUE ORDER BY "startTime" DESC LIMIT $1) ORDER BY "startTime" DESC LIMIT $1`;
    if (limit === 50) return this._cached('recentSessions', async () => {
      const result = await this.pool.query(q, [limit]);
      const seen = new Set();
      return result.rows.filter(r => { if (seen.has(r.id)) return false; seen.add(r.id); return true; }).map(r => this._rowToSession(r));
    });
    const result = await this.pool.query(q, [limit]);
    const seen = new Set();
    return result.rows.filter(r => { if (seen.has(r.id)) return false; seen.add(r.id); return true; }).map(r => this._rowToSession(r));
  }

  async getAllFinalizedSessions(limit = 100) {
    // Default to 100 for backwards compatibility, used by cache regeneration
    const result = await this.pool.query(`
      SELECT * FROM sessions
      WHERE ("raceFinalized" = TRUE AND "totalEntries" > 0) OR "isActive" = TRUE
      ORDER BY "startTime" DESC
      LIMIT $1
    `, [limit]);
    return result.rows.map(r => this._rowToSession(r));
  }

  async getSessionsPage(page = 1, limit = 25) {
    // Server-side pagination - only fetch what's needed for current page
    const offset = (page - 1) * limit;
    const result = await this.pool.query(`
      SELECT * FROM sessions
      WHERE "raceFinalized" = TRUE AND "totalEntries" > 0
      ORDER BY "startTime" DESC
      LIMIT $1 OFFSET $2
    `, [limit, offset]);
    return result.rows.map(r => this._rowToSession(r));
  }

  async getSessionsCursor(cursor = null, limit = 25) {
    // Cursor-based pagination - O(1) performance regardless of page depth
    // cursor is the startTime of the last session from previous page
    let result;
    if (cursor) {
      result = await this.pool.query(`
        SELECT * FROM sessions
        WHERE "raceFinalized" = TRUE AND "totalEntries" > 0 AND "startTime" < $1
        ORDER BY "startTime" DESC
        LIMIT $2
      `, [cursor, limit]);
    } else {
      result = await this.pool.query(`
        SELECT * FROM sessions
        WHERE "raceFinalized" = TRUE AND "totalEntries" > 0
        ORDER BY "startTime" DESC
        LIMIT $1
      `, [limit]);
    }
    const sessions = result.rows.map(r => this._rowToSession(r));
    const nextCursor = sessions.length === limit ? sessions[sessions.length - 1].startTime : null;
    return { sessions, nextCursor };
  }

  async searchSessionsByPlayer(guid, limit = 100) {
    const result = await this.pool.query(`SELECT s.* FROM sessions s INNER JOIN player_sessions ps ON s.id = ps."sessionId" WHERE ps."playerGuid" = $1 AND s."raceFinalized" = TRUE ORDER BY s."startTime" DESC LIMIT $2`, [guid.toUpperCase(), limit]);
    return result.rows.map(r => this._rowToSession(r));
  }

  async getSession(id) {
    const result = await this.pool.query('SELECT * FROM sessions WHERE id = $1', [id]);
    return result.rows.length ? this._rowToSession(result.rows[0]) : null;
  }

  async getActiveSessions() {
    const result = await this.pool.query(`SELECT * FROM sessions WHERE "isActive" = TRUE AND "hasFinished" = FALSE`);
    return result.rows.map(r => this._rowToSession(r));
  }

  async getTotalFinalizedSessionsCount() {
    return this._cached('sessionsCount', async () => {
      const result = await this.pool.query(`SELECT COUNT(*) as count FROM sessions WHERE "raceFinalized" = TRUE AND "totalEntries" > 0`);
      return parseInt(result.rows[0].count) || 0;
    });
  }

  async getTotalLapsCount() {
    return this._cached('totalLapsCount', async () => {
      // Query the JSONB arrays to get accurate warmup vs race lap breakdown
      const result = await this.pool.query(`
        SELECT
          COALESCE(SUM((SELECT SUM((elem->>'totalLaps')::int) FROM jsonb_array_elements("warmupResults") as elem)), 0) as warmup_laps,
          COALESCE(SUM((SELECT SUM((elem->>'totalLaps')::int) FROM jsonb_array_elements("raceResults") as elem)), 0) as race_laps
        FROM sessions
        WHERE "raceFinalized" = TRUE
      `);
      const warmupLaps = parseInt(result.rows[0].warmup_laps) || 0;
      const raceLaps = parseInt(result.rows[0].race_laps) || 0;
      return { warmupLaps, raceLaps, totalLaps: warmupLaps + raceLaps };
    });
  }

  async getMostActiveTrack() {
    return this._cached('mostActiveTrack', async () => {
      const result = await this.pool.query(`
        SELECT "trackName", COUNT(*) as count
        FROM sessions
        WHERE "raceFinalized" = TRUE AND "totalEntries" > 0 AND "trackName" IS NOT NULL AND "trackName" != ''
        GROUP BY "trackName"
        ORDER BY count DESC
        LIMIT 1
      `);
      if (result.rows.length === 0) return null;
      return { name: result.rows[0].trackName, count: parseInt(result.rows[0].count) };
    });
  }

  _rowToSession(r) {
    return { id: r.id, serverId: r.serverId, serverName: r.serverName, trackName: r.trackName, eventName: r.eventName, sessionType: r.sessionType, currentSessionPhase: r.currentSessionPhase, sessionState: r.sessionState, weatherConditions: r.weatherConditions, airTemperature: r.airTemperature, trackLength: r.trackLength, startTime: r.startTime ? parseInt(r.startTime) : null, endTime: r.endTime ? parseInt(r.endTime) : null, warmupResults: r.warmupResults || [], raceResults: r.raceResults || [], totalEntries: r.totalEntries, hasFinished: r.hasFinished, raceFinalized: r.raceFinalized, isActive: r.isActive, createdAt: r.createdAt ? parseInt(r.createdAt) : null };
  }

  async checkSinglePlayerPB(rec) {
    const { playerGuid, playerName, trackName, lapTime, sessionType, bikeName, bikeCategory } = rec;
    const id = `${playerGuid}_${trackName}`;
    const now = Date.now();
    const client = await this.pool.connect();
    try {
      const ex = await client.query('SELECT "lapTime" FROM track_records WHERE id = $1', [id]);
      const exPB = ex.rows.length ? ex.rows[0].lapTime : null;
      const isPB = !exPB || lapTime < exPB;
      if (isPB) {
        const imp = exPB ? exPB - lapTime : 0;
        await client.query(`INSERT INTO track_records (id, "playerGuid", "playerName", "trackName", "lapTime", "bikeName", "bikeCategory", "sessionType", "setAt") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9) ON CONFLICT (id) DO UPDATE SET "lapTime" = EXCLUDED."lapTime", "playerName" = EXCLUDED."playerName", "bikeName" = EXCLUDED."bikeName", "bikeCategory" = EXCLUDED."bikeCategory", "sessionType" = EXCLUDED."sessionType", "setAt" = EXCLUDED."setAt" WHERE EXCLUDED."lapTime" < track_records."lapTime"`, [id, playerGuid, playerName, trackName, lapTime, bikeName || null, bikeCategory || null, sessionType, now]);
        console.log(`[PB] ${playerName} ${trackName}: ${lapTime}s${imp > 0 ? ` (-${imp.toFixed(3)}s)` : ''}`);
        this._invalidate('trackRecords');
        return { isPB: true, lapTime, previousBest: exPB, improvement: imp, playerName, trackName };
      }
      return { isPB: false, lapTime, currentBest: exPB };
    } finally { client.release(); }
  }

  async getTrackList() {
    const result = await this.pool.query(`SELECT "trackName", COUNT(*) as "recordCount", MIN("lapTime") as "bestTime" FROM track_records GROUP BY "trackName" ORDER BY "trackName"`);
    return result.rows.map(r => ({ trackName: r.trackName, recordCount: parseInt(r.recordCount), bestTime: r.bestTime }));
  }

  async getTrackRecords(trackName, limit = 100, cat = null) {
    let q = `SELECT * FROM track_records WHERE "trackName" = $1`;
    const params = [trackName];
    if (cat) { q += ` AND "bikeCategory" = $2`; params.push(cat); }
    q += ` ORDER BY "lapTime" ASC LIMIT $${params.length + 1}`;
    params.push(limit);
    const result = await this.pool.query(q, params);
    return result.rows.map(r => this._rowToRecord(r));
  }

  async getPlayerRecords(guid) {
    const result = await this.pool.query(`SELECT * FROM track_records WHERE "playerGuid" = $1 ORDER BY "setAt" DESC`, [guid]);
    return result.rows.map(r => this._rowToRecord(r));
  }

  // For bulk API - limited data for fast homepage loading
  async getTrackRecordsForBulk() {
    return this._cached('trackRecords', async () => {
      // Top 10 per track for bulk response - keeps homepage fast
      const result = await this.pool.query(`
        SELECT * FROM (
          SELECT *, ROW_NUMBER() OVER (PARTITION BY "trackName" ORDER BY "lapTime" ASC) as rn
          FROM track_records
        ) ranked
        WHERE rn <= 10
        ORDER BY "trackName", "lapTime" ASC
      `);
      return result.rows.map(r => this._rowToRecord(r));
    });
  }

  // Full records - used by dedicated Records page with pagination
  async getAllTrackRecords() {
    const result = await this.pool.query(`SELECT * FROM track_records ORDER BY "trackName", "lapTime" ASC`);
    return result.rows.map(r => this._rowToRecord(r));
  }

  // Paginated track records for a specific track - FAST with proper indexes
  async getTrackRecordsPaginated(trackName, page = 1, limit = 50) {
    const offset = (page - 1) * limit;
    const [records, countResult] = await Promise.all([
      this.pool.query(`
        SELECT *, ROW_NUMBER() OVER (ORDER BY "lapTime" ASC) as position
        FROM track_records
        WHERE "trackName" = $1
        ORDER BY "lapTime" ASC
        LIMIT $2 OFFSET $3
      `, [trackName, limit, offset]),
      this.pool.query(`SELECT COUNT(*) FROM track_records WHERE "trackName" = $1`, [trackName])
    ]);
    return {
      records: records.rows.map(r => ({ ...this._rowToRecord(r), position: parseInt(r.position) })),
      total: parseInt(countResult.rows[0].count),
      page,
      totalPages: Math.ceil(parseInt(countResult.rows[0].count) / limit)
    };
  }

  // Find player's position on a specific track
  async getPlayerTrackPosition(trackName, playerGuid) {
    const result = await this.pool.query(`
      SELECT position FROM (
        SELECT "playerGuid", ROW_NUMBER() OVER (ORDER BY "lapTime" ASC) as position
        FROM track_records WHERE "trackName" = $1
      ) ranked WHERE "playerGuid" = $2
    `, [trackName, playerGuid.toUpperCase()]);
    return result.rows[0]?.position || null;
  }

  // Get list of all tracks with record counts - cached for performance
  async getTrackList() {
    return this._cached('trackList', async () => {
      const result = await this.pool.query(`
        SELECT "trackName", COUNT(*) as count, MIN("lapTime") as bestTime
        FROM track_records
        GROUP BY "trackName"
        ORDER BY "trackName" ASC
      `);
      return result.rows.map(r => ({
        trackName: r.trackName,
        recordCount: parseInt(r.count),
        bestTime: r.bestTime
      }));
    });
  }

  // Lightweight avatar lookup - just GUID and avatar URL for ALL players
  // Much smaller payload than full player data
  async getAllPlayerAvatars() {
    return this._cached('playerAvatars', async () => {
      const result = await this.pool.query(`
        SELECT guid, "steamAvatarUrl"
        FROM players
        WHERE "steamAvatarUrl" IS NOT NULL AND "steamAvatarUrl" != ''
      `);
      // Return as object map for fast lookups: { GUID: avatarUrl }
      const avatarMap = {};
      result.rows.forEach(r => {
        avatarMap[r.guid] = r.steamAvatarUrl;
      });
      return avatarMap;
    });
  }

  // Get REAL total counts for stats display (not limited array lengths!)
  async getTotalCounts() {
    return this._cached('totalCounts', async () => {
      const [playersResult, recordsResult, sessionsResult] = await Promise.all([
        this.pool.query('SELECT COUNT(*) FROM players'),
        this.pool.query('SELECT COUNT(*) FROM track_records'),
        this.pool.query('SELECT COUNT(*) FROM sessions WHERE "raceFinalized" = TRUE AND "totalEntries" > 0')
      ]);
      return {
        totalPlayersCount: parseInt(playersResult.rows[0].count),
        totalRecordsCount: parseInt(recordsResult.rows[0].count),
        totalSessionsCount: parseInt(sessionsResult.rows[0].count)
      };
    });
  }

  async getTopTrackRecords(perTrack = 3, cat = null) {
    let where = '';
    const params = [perTrack];
    if (cat) { where = `WHERE "bikeCategory" = $2`; params.push(cat); }
    const result = await this.pool.query(`SELECT * FROM (SELECT *, ROW_NUMBER() OVER (PARTITION BY "trackName" ORDER BY "lapTime" ASC) as rn FROM track_records ${where}) ranked WHERE rn <= $1 ORDER BY "trackName", "lapTime" ASC`, params);
    return result.rows.map(r => this._rowToRecord(r));
  }

  _rowToRecord(r) {
    return { id: r.id, playerGuid: r.playerGuid, playerName: r.playerName, trackName: r.trackName, lapTime: r.lapTime, bikeName: r.bikeName, bikeCategory: r.bikeCategory, serverName: r.serverName, sessionId: r.sessionId, sessionType: r.sessionType, setAt: r.setAt ? parseInt(r.setAt) : null };
  }

  async batchInsertContacts(contacts) {
    if (!contacts?.length) return;
    const client = await this.pool.connect();
    try {
      await client.query('BEGIN');
      for (const c of contacts) {
        const id = `${c.sessionId}_${c.time}_${c.raceNumber1}_${c.raceNumber2}`;
        const wall = c.raceNumber1 === -1 || c.raceNumber2 === -1;
        await client.query(`INSERT INTO contacts (id, "sessionId", time, "playerGuid1", "playerName1", "raceNumber1", "playerGuid2", "playerName2", "raceNumber2", "isWallContact", "relativeImpactVelocity", "createdAt") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12) ON CONFLICT (id) DO NOTHING`, [id, c.sessionId, c.time, c.playerGuid1 || null, c.playerName1 || null, c.raceNumber1, c.playerGuid2 || null, c.playerName2 || null, c.raceNumber2, wall, c.relativeImpactVelocity || 0, Date.now()]);
      }
      await client.query('COMMIT');
    } catch (err) { await client.query('ROLLBACK'); throw err; }
    finally { client.release(); }
  }

  async batchInsertHoleshots(holeshots) {
    if (!holeshots?.length) return;
    const client = await this.pool.connect();
    try {
      await client.query('BEGIN');
      for (const h of holeshots) {
        const id = `${h.sessionId}_${h.playerGuid}`;
        await client.query(`INSERT INTO holeshots (id, "sessionId", "playerGuid", "playerName", "raceNumber", "holeshotTime", "trackName", "createdAt") VALUES ($1, $2, $3, $4, $5, $6, $7, $8) ON CONFLICT (id) DO NOTHING`, [id, h.sessionId, h.playerGuid, h.playerName, h.raceNumber || 0, h.holeshotTime, h.trackName || null, Date.now()]);
      }
      await client.query('COMMIT');
    } catch (err) { await client.query('ROLLBACK'); throw err; }
    finally { client.release(); }
  }

  async getCompleteDataPackage() {
    const [players, recentSessions, trackList, totalPlayers, topMMR, topSR] = await Promise.all([this.getAllPlayers(), this.getRecentSessions(100), this.getTrackList(), this.getTotalPlayersCount(), this.getTopPlayersByMMR(100), this.getTopPlayersBySR(100)]);
    return { players, recentSessions, trackList, totalPlayers, leaderboards: { mmr: topMMR, safetyRating: topSR } };
  }

  async initLeaderTable() { console.log('[LEADER] Ready'); }

  async tryAcquireLeadership(machineId, staleMs = 15000) {
    const now = Date.now();
    const client = await this.pool.connect();
    try {
      const result = await client.query('SELECT machine_id, last_heartbeat FROM leader_election WHERE id = $1', ['primary']);
      if (!result.rows.length) {
        try {
          await client.query('INSERT INTO leader_election (id, machine_id, last_heartbeat, acquired_at) VALUES ($1, $2, $3, $4)', ['primary', machineId, now, now]);
          console.log(`[LEADER] ${machineId} became leader`);
          return true;
        } catch { return false; }
      }
      const cur = result.rows[0];
      const age = now - parseInt(cur.last_heartbeat);
      if (cur.machine_id === machineId) {
        await client.query('UPDATE leader_election SET last_heartbeat = $1 WHERE id = $2 AND machine_id = $3', [now, 'primary', machineId]);
        return true;
      }
      if (age > staleMs) {
        const upd = await client.query('UPDATE leader_election SET machine_id = $1, last_heartbeat = $2, acquired_at = $3 WHERE id = $4 AND last_heartbeat < $5', [machineId, now, now, 'primary', now - staleMs]);
        if (upd.rowCount) { console.log(`[LEADER] ${machineId} took over from stale`); return true; }
      }
      return false;
    } finally { client.release(); }
  }

  async sendLeaderHeartbeat(machineId) {
    try {
      const result = await this.pool.query('UPDATE leader_election SET last_heartbeat = $1 WHERE id = $2 AND machine_id = $3', [Date.now(), 'primary', machineId]);
      return result.rowCount > 0;
    } catch { return false; }
  }

  async isLeader(machineId) {
    try {
      const result = await this.pool.query('SELECT machine_id FROM leader_election WHERE id = $1', ['primary']);
      return result.rows.length > 0 && result.rows[0].machine_id === machineId;
    } catch { return false; }
  }

  async releaseLeadership(machineId) {
    try {
      await this.pool.query('DELETE FROM leader_election WHERE id = $1 AND machine_id = $2', ['primary', machineId]);
      console.log(`[LEADER] ${machineId} released`);
    } catch (err) { console.error('[LEADER] Release failed:', err.message); }
  }

  async addBanHistory(e) {
    const id = `ban_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    await this.pool.query(`INSERT INTO ban_history (id, "playerGuid", "playerName", action, reason, duration, "durationType", "isGlobal", "isPermanent", "expiresAt", "performedBy", "sourceManager", "serverName", "evidenceUrl", "createdAt") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)`, [id, e.playerGuid, e.playerName, e.action, e.reason || null, e.duration || null, e.durationType || null, e.isGlobal || false, e.isPermanent || false, e.expiresAt || null, e.performedBy || 'System', e.sourceManager || null, e.serverName || null, e.evidenceUrl || null, Date.now()]);
    return id;
  }

  async getBanHistory(guid) {
    const result = await this.pool.query(`SELECT * FROM ban_history WHERE UPPER("playerGuid") = UPPER($1) ORDER BY "createdAt" DESC`, [guid]);
    return result.rows.map(r => ({ id: r.id, playerGuid: r.playerGuid, playerName: r.playerName, action: r.action, reason: r.reason, duration: r.duration, durationType: r.durationType, isGlobal: r.isGlobal, isPermanent: r.isPermanent, expiresAt: r.expiresAt ? parseInt(r.expiresAt) : null, performedBy: r.performedBy, sourceManager: r.sourceManager, serverName: r.serverName, evidenceUrl: r.evidenceUrl || null, createdAt: r.createdAt ? parseInt(r.createdAt) : null }));
  }

  async getAllBanHistory(limit = 100) {
    const result = await this.pool.query(`SELECT * FROM ban_history ORDER BY "createdAt" DESC LIMIT $1`, [limit]);
    return result.rows.map(r => ({ id: r.id, playerGuid: r.playerGuid, playerName: r.playerName, action: r.action, reason: r.reason, duration: r.duration, durationType: r.durationType, isGlobal: r.isGlobal, isPermanent: r.isPermanent, expiresAt: r.expiresAt ? parseInt(r.expiresAt) : null, performedBy: r.performedBy, sourceManager: r.sourceManager, createdAt: r.createdAt ? parseInt(r.createdAt) : null }));
  }

  async deleteBanHistoryEntry(id) {
    const result = await this.pool.query(`DELETE FROM ban_history WHERE id = $1 RETURNING id`, [id]);
    return result.rows.length > 0;
  }

  async createWarning(w) {
    const id = `warning_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
    await this.pool.query(`INSERT INTO player_warnings (id, "playerGuid", "playerName", reason, "warnedBy", "warnedByGuid", "reportId", "createdAt") VALUES ($1, $2, $3, $4, $5, $6, $7, $8)`, [id, w.playerGuid, w.playerName, w.reason, w.warnedBy, w.warnedByGuid || null, w.reportId || null, Date.now()]);
    return { id, ...w };
  }

  async getPlayerWarnings(guid) {
    const result = await this.pool.query(`SELECT * FROM player_warnings WHERE "playerGuid" = $1 ORDER BY "createdAt" DESC`, [guid]);
    return result.rows;
  }

  async deleteWarning(id) {
    const result = await this.pool.query(`DELETE FROM player_warnings WHERE id = $1 RETURNING id`, [id]);
    return result.rows.length > 0;
  }

  async acknowledgeWarning(id, guid) {
    const result = await this.pool.query(`UPDATE player_warnings SET acknowledged = TRUE, "acknowledgedAt" = $1 WHERE id = $2 AND "playerGuid" = $3 AND acknowledged = FALSE RETURNING *`, [Date.now(), id, guid]);
    return result.rows[0] || null;
  }

  async getUnacknowledgedWarnings(guid) {
    const result = await this.pool.query(`SELECT * FROM player_warnings WHERE "playerGuid" = $1 AND acknowledged = FALSE ORDER BY "createdAt" DESC`, [guid]);
    return result.rows;
  }

  async getRecentAcknowledgedWarnings(limit = 50) {
    const result = await this.pool.query(`SELECT * FROM player_warnings WHERE acknowledged = TRUE ORDER BY "acknowledgedAt" DESC LIMIT $1`, [limit]);
    return result.rows;
  }

  async createBanAppeal(a) {
    const id = `appeal_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const now = Date.now();
    const result = await this.pool.query(`INSERT INTO ban_appeals (id, "playerGuid", "playerName", "userId", "banReason", "banDate", "banExpiry", "isPermanent", "serverName", "isGlobal", "appealReason", "additionalInfo", "videoUrl", status, "createdAt", "updatedAt") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16) RETURNING *`, [id, a.playerGuid, a.playerName, a.userId, a.banReason || null, a.banDate || null, a.banExpiry || null, a.isPermanent || false, a.serverName || null, a.isGlobal || false, a.appealReason, a.additionalInfo || null, a.videoUrl || null, 'open', now, now]);
    return this._rowToAppeal(result.rows[0]);
  }

  async getUserAppeals(userId) {
    const result = await this.pool.query(`SELECT * FROM ban_appeals WHERE "userId" = $1 ORDER BY "createdAt" DESC`, [userId]);
    return result.rows.map(r => this._rowToAppeal(r));
  }

  async getAppealsByPlayer(guid) {
    const result = await this.pool.query(`SELECT * FROM ban_appeals WHERE UPPER("playerGuid") = UPPER($1) ORDER BY "createdAt" DESC`, [guid]);
    return result.rows.map(r => this._rowToAppeal(r));
  }

  async getAllAppeals(status = null) {
    let q = 'SELECT * FROM ban_appeals';
    const params = [];
    if (status) { q += ' WHERE status = $1'; params.push(status); }
    q += ' ORDER BY "createdAt" DESC';
    const result = await this.pool.query(q, params);
    return result.rows.map(r => this._rowToAppeal(r));
  }

  async getAppeal(id) {
    const result = await this.pool.query('SELECT * FROM ban_appeals WHERE id = $1', [id]);
    return result.rows.length ? this._rowToAppeal(result.rows[0]) : null;
  }

  async claimAppeal(id, admin, adminGuid = null) {
    const now = Date.now();
    const result = await this.pool.query(`UPDATE ban_appeals SET status = 'claimed', "claimedBy" = $1, "claimedByGuid" = $2, "claimedAt" = $3, "updatedAt" = $4 WHERE id = $5 AND status = 'open' RETURNING *`, [admin, adminGuid, now, now, id]);
    return result.rows.length ? this._rowToAppeal(result.rows[0]) : null;
  }

  async transferAppeal(id, newGuid, newName) {
    const now = Date.now();
    const result = await this.pool.query(`UPDATE ban_appeals SET "claimedBy" = $1, "claimedByGuid" = $2, "updatedAt" = $3 WHERE id = $4 AND status = 'claimed' RETURNING *`, [newName, newGuid, now, id]);
    return result.rows.length ? this._rowToAppeal(result.rows[0]) : null;
  }

  async resolveAppeal(id, admin, adminGuid, accepted, resolution, cooldownHrs = 24) {
    const now = Date.now();
    const cd = accepted ? null : now + (cooldownHrs * 60 * 60 * 1000);
    const result = await this.pool.query(`UPDATE ban_appeals SET status = $1, "resolvedBy" = $2, "resolvedByGuid" = $3, "resolvedAt" = $4, resolution = $5, "cooldownUntil" = $6, "updatedAt" = $7 WHERE id = $8 RETURNING *`, [accepted ? 'accepted' : 'denied', admin, adminGuid, now, resolution, cd, now, id]);
    return result.rows.length ? this._rowToAppeal(result.rows[0]) : null;
  }

  async canUserAppeal(userId, guid) {
    const result = await this.pool.query(`SELECT "cooldownUntil" FROM ban_appeals WHERE "userId" = $1 AND UPPER("playerGuid") = UPPER($2) AND status = 'denied' AND "cooldownUntil" > $3 ORDER BY "createdAt" DESC LIMIT 1`, [userId, guid, Date.now()]);
    if (result.rows.length) return { canAppeal: false, cooldownUntil: parseInt(result.rows[0].cooldownUntil) };
    const open = await this.pool.query(`SELECT id FROM ban_appeals WHERE "userId" = $1 AND UPPER("playerGuid") = UPPER($2) AND status IN ('open', 'claimed') LIMIT 1`, [userId, guid]);
    if (open.rows.length) return { canAppeal: false, hasOpenAppeal: true };
    return { canAppeal: true };
  }

  async autoResolveExpiredAppeals() {
    const now = Date.now();
    const result = await this.pool.query(`UPDATE ban_appeals SET status = 'accepted', "resolvedBy" = 'System', "resolvedAt" = $1, resolution = 'Ban expired - auto resolved', "updatedAt" = $1 WHERE status IN ('open', 'claimed') AND "isPermanent" = false AND "banExpiry" IS NOT NULL AND "banExpiry" < $1 RETURNING *`, [now]);
    if (result.rows.length) console.log(`[APPEAL] Auto-resolved ${result.rows.length}`);
    return result.rows.map(r => this._rowToAppeal(r));
  }

  _rowToAppeal(r) {
    return { id: r.id, appealIndex: r.appealIndex, playerGuid: r.playerGuid, playerName: r.playerName, userId: r.userId, banReason: r.banReason, banDate: r.banDate ? parseInt(r.banDate) : null, banExpiry: r.banExpiry ? parseInt(r.banExpiry) : null, isPermanent: r.isPermanent, serverName: r.serverName, isGlobal: r.isGlobal, appealReason: r.appealReason, additionalInfo: r.additionalInfo, videoUrl: r.videoUrl, status: r.status, claimedBy: r.claimedBy, claimedByGuid: r.claimedByGuid, claimedAt: r.claimedAt ? parseInt(r.claimedAt) : null, resolvedBy: r.resolvedBy, resolvedByGuid: r.resolvedByGuid, resolvedAt: r.resolvedAt ? parseInt(r.resolvedAt) : null, resolution: r.resolution, cooldownUntil: r.cooldownUntil ? parseInt(r.cooldownUntil) : null, createdAt: r.createdAt ? parseInt(r.createdAt) : null, updatedAt: r.updatedAt ? parseInt(r.updatedAt) : null };
  }

  async createReport(rp) {
    const id = `report_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const now = Date.now();
    const result = await this.pool.query(`INSERT INTO player_reports (id, "reporterGuid", "reporterName", "reporterUserId", "offenderGuid", "offenderName", "serverName", reason, description, "videoUrl", status, "createdAt", "updatedAt") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13) RETURNING *`, [id, rp.reporterGuid, rp.reporterName, rp.reporterUserId, rp.offenderGuid, rp.offenderName, rp.serverName || null, rp.reason, rp.description, rp.videoUrl, 'open', now, now]);
    return this._rowToReport(result.rows[0]);
  }

  async getUserReports(userId) {
    const result = await this.pool.query(`SELECT * FROM player_reports WHERE "reporterUserId" = $1 ORDER BY "createdAt" DESC`, [userId]);
    return result.rows.map(r => this._rowToReport(r));
  }

  async getAllReports(status = null) {
    let q = 'SELECT * FROM player_reports';
    const params = [];
    if (status) { q += ' WHERE status = $1'; params.push(status); }
    q += ' ORDER BY "createdAt" DESC';
    const result = await this.pool.query(q, params);
    return result.rows.map(r => this._rowToReport(r));
  }

  async getReport(id) {
    const result = await this.pool.query('SELECT * FROM player_reports WHERE id = $1', [id]);
    return result.rows.length ? this._rowToReport(result.rows[0]) : null;
  }

  async claimReport(id, admin, adminGuid = null) {
    const now = Date.now();
    const result = await this.pool.query(`UPDATE player_reports SET status = 'claimed', "claimedBy" = $1, "claimedByGuid" = $2, "claimedAt" = $3, "updatedAt" = $4 WHERE id = $5 AND status = 'open' RETURNING *`, [admin, adminGuid, now, now, id]);
    return result.rows.length ? this._rowToReport(result.rows[0]) : null;
  }

  async transferReport(id, newGuid, newName) {
    const now = Date.now();
    const result = await this.pool.query(`UPDATE player_reports SET "claimedBy" = $1, "claimedByGuid" = $2, "updatedAt" = $3 WHERE id = $4 AND status = 'claimed' RETURNING *`, [newName, newGuid, now, id]);
    return result.rows.length ? this._rowToReport(result.rows[0]) : null;
  }

  async resolveReport(id, admin, adminGuid, action, resolution) {
    const now = Date.now();
    const status = action === 'pending_ban' ? 'pending_ban' : action === 'no_action' ? 'no_action' : 'action_taken';
    const resolvedAt = action === 'pending_ban' ? null : now;
    const result = await this.pool.query(`UPDATE player_reports SET status = $1, "resolvedBy" = $2, "resolvedByGuid" = $3, "resolvedAt" = $4, resolution = $5, "actionTaken" = $6, "updatedAt" = $7 WHERE id = $8 RETURNING *`, [status, admin, adminGuid, resolvedAt, resolution, action, now, id]);
    return result.rows.length ? this._rowToReport(result.rows[0]) : null;
  }

  async deleteReport(id) {
    await this.pool.query(`DELETE FROM notifications WHERE "relatedId" = $1`, [id]);
    const result = await this.pool.query(`DELETE FROM player_reports WHERE id = $1 RETURNING id`, [id]);
    return result.rows.length > 0;
  }

  async deleteAppeal(id) {
    await this.pool.query(`DELETE FROM notifications WHERE "relatedId" = $1`, [id]);
    const result = await this.pool.query(`DELETE FROM ban_appeals WHERE id = $1 RETURNING id`, [id]);
    return result.rows.length > 0;
  }

  _rowToReport(r) {
    return { id: r.id, reportIndex: r.reportIndex, reporterGuid: r.reporterGuid, reporterName: r.reporterName, reporterUserId: r.reporterUserId, offenderGuid: r.offenderGuid, offenderName: r.offenderName, serverName: r.serverName, reason: r.reason, description: r.description, videoUrl: r.videoUrl, status: r.status, claimedBy: r.claimedBy, claimedByGuid: r.claimedByGuid, claimedAt: r.claimedAt ? parseInt(r.claimedAt) : null, resolvedBy: r.resolvedBy, resolvedByGuid: r.resolvedByGuid, resolvedAt: r.resolvedAt ? parseInt(r.resolvedAt) : null, resolution: r.resolution, actionTaken: r.actionTaken, createdAt: r.createdAt ? parseInt(r.createdAt) : null, updatedAt: r.updatedAt ? parseInt(r.updatedAt) : null };
  }

  async createNotification(n) {
    const id = `notif_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    await this.pool.query(`INSERT INTO notifications (id, "userId", type, title, message, link, read, "relatedId", "createdAt") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)`, [id, n.userId, n.type, n.title, n.message, n.link || null, false, n.relatedId || null, Date.now()]);
    return id;
  }

  async getUserNotifications(userId, limit = 50) {
    const result = await this.pool.query(`SELECT * FROM notifications WHERE "userId" = $1 ORDER BY "createdAt" DESC LIMIT $2`, [userId, limit]);
    return result.rows.map(r => ({ id: r.id, userId: r.userId, type: r.type, title: r.title, message: r.message, link: r.link, read: r.read, createdAt: r.createdAt ? parseInt(r.createdAt) : null }));
  }

  async getUnreadNotificationCount(userId) {
    const result = await this.pool.query(`SELECT COUNT(*) as count FROM notifications WHERE "userId" = $1 AND read = FALSE`, [userId]);
    return parseInt(result.rows[0].count);
  }

  async getUnreadNotificationCountsByType(userId) {
    const result = await this.pool.query(`SELECT SUM(CASE WHEN type LIKE '%appeal%' THEN 1 ELSE 0 END) as appeals, SUM(CASE WHEN type LIKE '%report%' THEN 1 ELSE 0 END) as reports FROM notifications WHERE "userId" = $1 AND read = FALSE`, [userId]);
    return { appeals: parseInt(result.rows[0].appeals) || 0, reports: parseInt(result.rows[0].reports) || 0 };
  }

  async getAdminPendingCounts() {
    const [a, r, t] = await Promise.all([this.pool.query(`SELECT COUNT(*) as count FROM ban_appeals WHERE status IN ('open', 'claimed')`), this.pool.query(`SELECT COUNT(*) as count FROM player_reports WHERE status IN ('open', 'claimed')`), this.pool.query(`SELECT COUNT(*) as count FROM support_tickets WHERE status IN ('pending', 'in_progress')`)]);
    return { appeals: parseInt(a.rows[0].count) || 0, reports: parseInt(r.rows[0].count) || 0, tickets: parseInt(t.rows[0].count) || 0 };
  }

  async markNotificationRead(id) { await this.pool.query('UPDATE notifications SET read = TRUE WHERE id = $1', [id]); }
  async markAllNotificationsRead(userId) { await this.pool.query('UPDATE notifications SET read = TRUE WHERE "userId" = $1', [userId]); }

  async createAnnouncement(a) {
    const id = `ann_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const now = Date.now();
    const result = await this.pool.query(`INSERT INTO announcements (id, title, message, type, active, "createdBy", "createdByName", "createdAt", "updatedAt", "expiresAt") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10) RETURNING *`, [id, a.title, a.message, a.type || 'info', true, a.createdBy, a.createdByName || null, now, now, a.expiresAt || null]);
    return this._rowToAnnouncement(result.rows[0]);
  }

  async getActiveAnnouncements() {
    const result = await this.pool.query(`SELECT * FROM announcements WHERE active = TRUE AND ("expiresAt" IS NULL OR "expiresAt" > $1) ORDER BY "createdAt" DESC`, [Date.now()]);
    return result.rows.map(r => this._rowToAnnouncement(r));
  }

  async getAllAnnouncements() {
    const result = await this.pool.query(`SELECT * FROM announcements ORDER BY "createdAt" DESC`);
    return result.rows.map(r => this._rowToAnnouncement(r));
  }

  async updateAnnouncement(id, u) {
    const now = Date.now();
    const result = await this.pool.query(`UPDATE announcements SET title = COALESCE($1, title), message = COALESCE($2, message), type = COALESCE($3, type), active = COALESCE($4, active), "expiresAt" = $5, "updatedAt" = $6 WHERE id = $7 RETURNING *`, [u.title || null, u.message || null, u.type || null, u.active !== undefined ? u.active : null, u.expiresAt !== undefined ? u.expiresAt : null, now, id]);
    return result.rows.length ? this._rowToAnnouncement(result.rows[0]) : null;
  }

  async toggleAnnouncementActive(id) {
    const result = await this.pool.query(`UPDATE announcements SET active = NOT active, "updatedAt" = $1 WHERE id = $2 RETURNING *`, [Date.now(), id]);
    return result.rows.length ? this._rowToAnnouncement(result.rows[0]) : null;
  }

  async deleteAnnouncement(id) {
    const result = await this.pool.query('DELETE FROM announcements WHERE id = $1 RETURNING id', [id]);
    return result.rows.length > 0;
  }

  _rowToAnnouncement(r) {
    if (!r) return null;
    return { id: r.id, title: r.title, message: r.message, type: r.type, active: r.active, createdBy: r.createdBy, createdByName: r.createdByName, createdAt: r.createdAt ? parseInt(r.createdAt) : null, updatedAt: r.updatedAt ? parseInt(r.updatedAt) : null, expiresAt: r.expiresAt ? parseInt(r.expiresAt) : null };
  }

  // Poll methods
  async createPoll(p) {
    const id = `poll_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const now = Date.now();
    const result = await this.pool.query(
      `INSERT INTO polls (id, question, options, votes, active, "createdBy", "createdByName", "createdAt", "expiresAt", "showResults")
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10) RETURNING *`,
      [id, p.question, JSON.stringify(p.options), '{}', true, p.createdBy, p.createdByName || null, now, p.expiresAt, p.showResults || false]
    );
    return this._rowToPoll(result.rows[0]);
  }

  async getActivePolls() {
    const now = Date.now();
    const result = await this.pool.query(
      `SELECT * FROM polls WHERE active = TRUE AND "expiresAt" > $1 ORDER BY "createdAt" DESC`,
      [now]
    );
    return result.rows.map(r => this._rowToPoll(r));
  }

  async getExpiredPolls() {
    const now = Date.now();
    const result = await this.pool.query(
      `SELECT * FROM polls WHERE "expiresAt" <= $1 ORDER BY "expiresAt" DESC LIMIT 50`,
      [now]
    );
    return result.rows.map(r => this._rowToPoll(r));
  }

  async getAllPolls() {
    const result = await this.pool.query(`SELECT * FROM polls ORDER BY "createdAt" DESC`);
    return result.rows.map(r => this._rowToPoll(r));
  }

  async getPoll(id) {
    const result = await this.pool.query('SELECT * FROM polls WHERE id = $1', [id]);
    return result.rows.length ? this._rowToPoll(result.rows[0]) : null;
  }

  async votePoll(pollId, odg, optionIndex) {
    // Get current poll
    const poll = await this.getPoll(pollId);
    if (!poll) return null;

    // Check if expired
    if (poll.expiresAt <= Date.now()) return { error: 'Poll has expired' };

    // Update votes - each user can only vote once
    const votes = poll.votes || {};
    votes[odg] = optionIndex;

    const result = await this.pool.query(
      `UPDATE polls SET votes = $1 WHERE id = $2 RETURNING *`,
      [JSON.stringify(votes), pollId]
    );
    return result.rows.length ? this._rowToPoll(result.rows[0]) : null;
  }

  async deletePoll(id) {
    const result = await this.pool.query('DELETE FROM polls WHERE id = $1 RETURNING id', [id]);
    return result.rows.length > 0;
  }

  async togglePollActive(id) {
    const result = await this.pool.query(
      `UPDATE polls SET active = NOT active WHERE id = $1 RETURNING *`,
      [id]
    );
    return result.rows.length ? this._rowToPoll(result.rows[0]) : null;
  }

  _rowToPoll(r) {
    if (!r) return null;
    const votes = typeof r.votes === 'string' ? JSON.parse(r.votes) : (r.votes || {});
    const options = typeof r.options === 'string' ? JSON.parse(r.options) : (r.options || []);

    // Calculate vote counts per option
    const voteCounts = options.map(() => 0);
    Object.values(votes).forEach(optIdx => {
      if (optIdx >= 0 && optIdx < voteCounts.length) voteCounts[optIdx]++;
    });
    const totalVotes = Object.keys(votes).length;

    return {
      id: r.id,
      question: r.question,
      options,
      votes,
      voteCounts,
      totalVotes,
      active: r.active,
      createdBy: r.createdBy,
      createdByName: r.createdByName,
      createdAt: r.createdAt ? parseInt(r.createdAt) : null,
      expiresAt: r.expiresAt ? parseInt(r.expiresAt) : null,
      showResults: r.showResults,
      isExpired: r.expiresAt ? parseInt(r.expiresAt) <= Date.now() : false
    };
  }

  async getAllFeatureRequests() {
    const result = await this.pool.query(`SELECT * FROM feature_requests ORDER BY (COALESCE(array_length(upvotes, 1), 0) - COALESCE(array_length(downvotes, 1), 0)) DESC, "createdAt" DESC`);
    return result.rows.map(r => this._rowToFeatureRequest(r));
  }

  async createFeatureRequest(d) {
    const id = `fr_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const result = await this.pool.query(`INSERT INTO feature_requests (id, title, description, type, status, "submittedBy", "submittedByName", "submittedByGuid", "createdAt") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9) RETURNING *`, [id, d.title, d.description, d.type || 'feature', 'pending', d.submittedBy, d.submittedByName, d.submittedByGuid || null, Date.now()]);
    return this._rowToFeatureRequest(result.rows[0]);
  }

  async updateFeatureRequest(id, u) {
    const result = await this.pool.query(`UPDATE feature_requests SET status = COALESCE($1, status), "developerComment" = COALESCE($2, "developerComment"), "updatedAt" = $3 WHERE id = $4 RETURNING *`, [u.status || null, u.developerComment !== undefined ? u.developerComment : null, Date.now(), id]);
    return result.rows.length ? this._rowToFeatureRequest(result.rows[0]) : null;
  }

  async voteFeatureRequest(id, odg, vote) {
    const now = Date.now();
    let q;
    if (vote === 'up') q = `UPDATE feature_requests SET upvotes = array_append(array_remove(upvotes, $1), $1), downvotes = array_remove(downvotes, $1), "updatedAt" = $2 WHERE id = $3 RETURNING *`;
    else if (vote === 'down') q = `UPDATE feature_requests SET downvotes = array_append(array_remove(downvotes, $1), $1), upvotes = array_remove(upvotes, $1), "updatedAt" = $2 WHERE id = $3 RETURNING *`;
    else q = `UPDATE feature_requests SET upvotes = array_remove(upvotes, $1), downvotes = array_remove(downvotes, $1), "updatedAt" = $2 WHERE id = $3 RETURNING *`;
    const result = await this.pool.query(q, [odg, now, id]);
    return result.rows.length ? this._rowToFeatureRequest(result.rows[0]) : null;
  }

  async deleteFeatureRequest(id) {
    const result = await this.pool.query('DELETE FROM feature_requests WHERE id = $1 RETURNING id', [id]);
    return result.rows.length > 0;
  }

  _rowToFeatureRequest(r) {
    if (!r) return null;
    const up = r.upvotes || [], down = r.downvotes || [];
    return { id: r.id, requestIndex: r.requestIndex, title: r.title, description: r.description, type: r.type, status: r.status, submittedBy: r.submittedBy, submittedByName: r.submittedByName, submittedByGuid: r.submittedByGuid, developerComment: r.developerComment, upvotes: up, downvotes: down, voteScore: up.length - down.length, createdAt: r.createdAt ? parseInt(r.createdAt) : null, updatedAt: r.updatedAt ? parseInt(r.updatedAt) : null };
  }

  async createSupportTicket(t) {
    const id = `ticket_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const now = Date.now();
    await this.pool.query(`INSERT INTO support_tickets (id, "userId", "userEmail", "reporterGuid", "reporterName", "issueType", subject, description, status, "createdAt", "updatedAt") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, 'pending', $9, $9)`, [id, t.userId, t.userEmail || null, t.reporterGuid || null, t.reporterName || null, t.issueType, t.subject, t.description, now]);
    return { id, ...t, status: 'pending', createdAt: now, updatedAt: now };
  }

  async getAllSupportTickets(status = null) {
    let q = 'SELECT * FROM support_tickets';
    const params = [];
    if (status) { q += ' WHERE status = $1'; params.push(status); }
    q += ' ORDER BY "createdAt" DESC';
    const result = await this.pool.query(q, params);
    return result.rows.map(r => this._rowToTicket(r));
  }

  async getSupportTicket(id) {
    const result = await this.pool.query('SELECT * FROM support_tickets WHERE id = $1', [id]);
    return this._rowToTicket(result.rows[0]);
  }

  async getUserSupportTickets(userId) {
    const result = await this.pool.query('SELECT * FROM support_tickets WHERE "userId" = $1 ORDER BY "createdAt" DESC', [userId]);
    return result.rows.map(r => this._rowToTicket(r));
  }

  async updateSupportTicket(id, d) {
    const now = Date.now();
    const fields = [], vals = [];
    let n = 1;
    if (d.status !== undefined) { fields.push(`status = $${n++}`); vals.push(d.status); }
    if (d.resolution !== undefined) { fields.push(`resolution = $${n++}`); vals.push(d.resolution); }
    if (d.resolvedBy !== undefined) { fields.push(`"resolvedBy" = $${n++}`); vals.push(d.resolvedBy); }
    if (d.resolvedByGuid !== undefined) { fields.push(`"resolvedByGuid" = $${n++}`); vals.push(d.resolvedByGuid); }
    if (d.status === 'resolved') { fields.push(`"resolvedAt" = $${n++}`); vals.push(now); }
    fields.push(`"updatedAt" = $${n++}`); vals.push(now); vals.push(id);
    const result = await this.pool.query(`UPDATE support_tickets SET ${fields.join(', ')} WHERE id = $${n} RETURNING *`, vals);
    return this._rowToTicket(result.rows[0]);
  }

  async deleteSupportTicket(id) {
    const result = await this.pool.query('DELETE FROM support_tickets WHERE id = $1 RETURNING id', [id]);
    return result.rows.length > 0;
  }

  _rowToTicket(r) {
    if (!r) return null;
    return { id: r.id, userId: r.userId, userEmail: r.userEmail, reporterGuid: r.reporterGuid, reporterName: r.reporterName, issueType: r.issueType, subject: r.subject, description: r.description, status: r.status, resolution: r.resolution, resolvedBy: r.resolvedBy, resolvedByGuid: r.resolvedByGuid, resolvedAt: r.resolvedAt ? parseInt(r.resolvedAt) : null, createdAt: r.createdAt ? parseInt(r.createdAt) : null, updatedAt: r.updatedAt ? parseInt(r.updatedAt) : null };
  }

  async getMessageTemplates() {
    const result = await this.pool.query('SELECT * FROM message_templates WHERE id = $1', ['default']);
    if (!result.rows.length) return { banPrivateMessageEnabled: true, banPrivateMessageTemplate: 'You have been banned for {duration}. Reason: {reason}', banGlobalMessageEnabled: true, banGlobalMessageTemplate: '{name} has been banned for {duration}. Reason: {reason}', unbanMessageEnabled: true, unbanMessageTemplate: '{name} has been unbanned', warningMessageEnabled: true, warningMessageTemplate: 'WARNING: {reason}', warningGlobalMessageEnabled: true, warningGlobalMessageTemplate: '{name} has received a warning: {reason}', kickPrivateMessageEnabled: true, kickPrivateMessageTemplate: 'You have been kicked. Reason: {reason}', kickGlobalMessageEnabled: true, kickGlobalMessageTemplate: '{name} has been kicked. Reason: {reason}' };
    const r = result.rows[0];
    return { banPrivateMessageEnabled: r.banPrivateMessageEnabled, banPrivateMessageTemplate: r.banPrivateMessageTemplate, banGlobalMessageEnabled: r.banGlobalMessageEnabled, banGlobalMessageTemplate: r.banGlobalMessageTemplate, unbanMessageEnabled: r.unbanMessageEnabled, unbanMessageTemplate: r.unbanMessageTemplate, warningMessageEnabled: r.warningMessageEnabled, warningMessageTemplate: r.warningMessageTemplate, warningGlobalMessageEnabled: r.warningGlobalMessageEnabled, warningGlobalMessageTemplate: r.warningGlobalMessageTemplate, kickPrivateMessageEnabled: r.kickPrivateMessageEnabled, kickPrivateMessageTemplate: r.kickPrivateMessageTemplate, kickGlobalMessageEnabled: r.kickGlobalMessageEnabled, kickGlobalMessageTemplate: r.kickGlobalMessageTemplate, updatedAt: r.updatedAt ? parseInt(r.updatedAt) : null };
  }

  async updateMessageTemplates(d) {
    await this.pool.query(`UPDATE message_templates SET "banPrivateMessageEnabled" = COALESCE($1, "banPrivateMessageEnabled"), "banPrivateMessageTemplate" = COALESCE($2, "banPrivateMessageTemplate"), "banGlobalMessageEnabled" = COALESCE($3, "banGlobalMessageEnabled"), "banGlobalMessageTemplate" = COALESCE($4, "banGlobalMessageTemplate"), "unbanMessageEnabled" = COALESCE($5, "unbanMessageEnabled"), "unbanMessageTemplate" = COALESCE($6, "unbanMessageTemplate"), "warningMessageEnabled" = COALESCE($7, "warningMessageEnabled"), "warningMessageTemplate" = COALESCE($8, "warningMessageTemplate"), "warningGlobalMessageEnabled" = COALESCE($9, "warningGlobalMessageEnabled"), "warningGlobalMessageTemplate" = COALESCE($10, "warningGlobalMessageTemplate"), "kickPrivateMessageEnabled" = COALESCE($11, "kickPrivateMessageEnabled"), "kickPrivateMessageTemplate" = COALESCE($12, "kickPrivateMessageTemplate"), "kickGlobalMessageEnabled" = COALESCE($13, "kickGlobalMessageEnabled"), "kickGlobalMessageTemplate" = COALESCE($14, "kickGlobalMessageTemplate"), "updatedAt" = $15 WHERE id = 'default'`, [d.banPrivateMessageEnabled, d.banPrivateMessageTemplate, d.banGlobalMessageEnabled, d.banGlobalMessageTemplate, d.unbanMessageEnabled, d.unbanMessageTemplate, d.warningMessageEnabled, d.warningMessageTemplate, d.warningGlobalMessageEnabled, d.warningGlobalMessageTemplate, d.kickPrivateMessageEnabled, d.kickPrivateMessageTemplate, d.kickGlobalMessageEnabled, d.kickGlobalMessageTemplate, Date.now()]);
    return this.getMessageTemplates();
  }

  async getAllAutomatedMessages() {
    const result = await this.pool.query(`SELECT * FROM automated_messages ORDER BY "createdAt" DESC`);
    return result.rows.map(r => ({ id: r.id, message: r.message, intervalMinutes: r.intervalMinutes, isEnabled: r.isEnabled, isGlobal: r.isGlobal, serverId: r.serverId, serverName: r.serverName, lastSent: r.lastSent ? parseInt(r.lastSent) : null, createdAt: r.createdAt ? parseInt(r.createdAt) : null, updatedAt: r.updatedAt ? parseInt(r.updatedAt) : null }));
  }

  async getAutomatedMessagesByServer(serverId) {
    const result = await this.pool.query(`SELECT * FROM automated_messages WHERE "serverId" = $1 OR "isGlobal" = true ORDER BY "createdAt" DESC`, [serverId]);
    return result.rows.map(r => ({ id: r.id, message: r.message, intervalMinutes: r.intervalMinutes, isEnabled: r.isEnabled, isGlobal: r.isGlobal, serverId: r.serverId, serverName: r.serverName, lastSent: r.lastSent ? parseInt(r.lastSent) : null, createdAt: r.createdAt ? parseInt(r.createdAt) : null, updatedAt: r.updatedAt ? parseInt(r.updatedAt) : null }));
  }

  async getDueAutomatedMessages() {
    const now = Date.now();
    const result = await this.pool.query(`SELECT * FROM automated_messages WHERE "isEnabled" = true AND ("lastSent" IS NULL OR ($1 - "lastSent") >= ("intervalMinutes" * 60 * 1000))`, [now]);
    return result.rows.map(r => ({ id: r.id, message: r.message, intervalMinutes: r.intervalMinutes, isEnabled: r.isEnabled, isGlobal: r.isGlobal, serverId: r.serverId, serverName: r.serverName, lastSent: r.lastSent ? parseInt(r.lastSent) : null, createdAt: r.createdAt ? parseInt(r.createdAt) : null, updatedAt: r.updatedAt ? parseInt(r.updatedAt) : null }));
  }

  async createAutomatedMessage(d) {
    const now = Date.now();
    const id = d.id || `msg_${now}_${Math.random().toString(36).substr(2, 9)}`;
    const ex = await this.pool.query(`SELECT COUNT(*) as count FROM automated_messages WHERE "intervalMinutes" = $1 AND "isEnabled" = true`, [d.intervalMinutes || 5]);
    const cnt = parseInt(ex.rows[0].count);
    const intMs = (d.intervalMinutes || 5) * 60 * 1000;
    let initLast = null;
    if (cnt > 0) initLast = now - intMs + (intMs / (cnt + 1)) * cnt;
    await this.pool.query(`INSERT INTO automated_messages (id, message, "intervalMinutes", "isEnabled", "isGlobal", "serverId", "serverName", "lastSent", "createdAt") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)`, [id, d.message, d.intervalMinutes || 5, d.isEnabled !== false, d.isGlobal || false, d.serverId || null, d.serverName || null, initLast, now]);
    return { id, message: d.message, intervalMinutes: d.intervalMinutes || 5, isEnabled: d.isEnabled !== false, isGlobal: d.isGlobal || false, serverId: d.serverId, serverName: d.serverName, createdAt: now };
  }

  async updateAutomatedMessage(id, d) {
    const now = Date.now();
    const fields = [], vals = [];
    let n = 1;
    if (d.message !== undefined) { fields.push(`message = $${n++}`); vals.push(d.message); }
    if (d.intervalMinutes !== undefined) { fields.push(`"intervalMinutes" = $${n++}`); vals.push(d.intervalMinutes); }
    if (d.isEnabled !== undefined) { fields.push(`"isEnabled" = $${n++}`); vals.push(d.isEnabled); }
    if (d.isGlobal !== undefined) { fields.push(`"isGlobal" = $${n++}`); vals.push(d.isGlobal); }
    if (d.serverId !== undefined) { fields.push(`"serverId" = $${n++}`); vals.push(d.serverId); }
    if (d.serverName !== undefined) { fields.push(`"serverName" = $${n++}`); vals.push(d.serverName); }
    fields.push(`"updatedAt" = $${n++}`); vals.push(now); vals.push(id);
    const result = await this.pool.query(`UPDATE automated_messages SET ${fields.join(', ')} WHERE id = $${n} RETURNING *`, vals);
    if (!result.rows.length) return null;
    const r = result.rows[0];
    return { id: r.id, message: r.message, intervalMinutes: r.intervalMinutes, isEnabled: r.isEnabled, isGlobal: r.isGlobal, serverId: r.serverId, serverName: r.serverName, lastSent: r.lastSent ? parseInt(r.lastSent) : null, createdAt: r.createdAt ? parseInt(r.createdAt) : null, updatedAt: r.updatedAt ? parseInt(r.updatedAt) : null };
  }

  async updateAutomatedMessageLastSent(id) { await this.pool.query(`UPDATE automated_messages SET "lastSent" = $1 WHERE id = $2`, [Date.now(), id]); }

  async deleteAutomatedMessage(id) {
    const result = await this.pool.query(`DELETE FROM automated_messages WHERE id = $1 RETURNING id`, [id]);
    return result.rows.length > 0;
  }

  async createDonation(d) {
    const id = `donation_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    await this.pool.query(`INSERT INTO donations (id, "stripePaymentId", "stripeCustomerId", email, name, amount, currency, status, message, "isAnonymous", "playerGuid", "playerName", "createdAt") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)`, [id, d.stripePaymentId || null, d.stripeCustomerId || null, d.email || null, d.name || null, d.amount, d.currency || 'usd', d.status || 'pending', d.message || null, d.isAnonymous || false, d.playerGuid || null, d.playerName || null, Date.now()]);
    return id;
  }

  async updateDonationStatus(stripePaymentId, status) {
    await this.pool.query(`UPDATE donations SET status = $1 WHERE "stripePaymentId" = $2`, [status, stripePaymentId]);
  }

  async getAllDonations() {
    const result = await this.pool.query(`SELECT * FROM donations ORDER BY "createdAt" DESC`);
    return result.rows.map(r => ({ id: r.id, stripePaymentId: r.stripePaymentId, stripeCustomerId: r.stripeCustomerId, email: r.email, name: r.name, amount: r.amount, currency: r.currency, status: r.status, message: r.message, isAnonymous: r.isAnonymous, playerGuid: r.playerGuid, playerName: r.playerName, createdAt: r.createdAt ? parseInt(r.createdAt) : null }));
  }

  async getDonationStats() {
    const result = await this.pool.query(`SELECT COUNT(*) as total, COALESCE(SUM(amount), 0) as "totalAmount", COUNT(CASE WHEN "createdAt" > $1 THEN 1 END) as "thisMonth", COALESCE(SUM(CASE WHEN "createdAt" > $1 THEN amount ELSE 0 END), 0) as "thisMonthAmount" FROM donations WHERE status = 'completed'`, [Date.now() - 30 * 24 * 60 * 60 * 1000]);
    const r = result.rows[0];
    return { totalDonations: parseInt(r.total), totalAmount: parseInt(r.totalAmount), thisMonthDonations: parseInt(r.thisMonth), thisMonthAmount: parseInt(r.thisMonthAmount) };
  }

  async close() { await this.pool.end(); console.log('[DB] Closed'); }
}
