import pg from 'pg';
const { Pool } = pg;

export class PostgresDatabaseManager {
  constructor(connectionString) {
    this.pool = new Pool({
      connectionString,
      max: 10,
      idleTimeoutMillis: 30000,
      connectionTimeoutMillis: 30000,
      keepAlive: true,
      keepAliveInitialDelayMillis: 10000,
      allowExitOnIdle: false,
    });

    this.pool.on('error', (err) => {
      console.error('[POSTGRES] Unexpected pool error:', err);
    });

    // Internal query cache for expensive operations
    this._queryCache = {
      playersSlim: { data: null, timestamp: 0, ttl: 2500 },    // 2.5s cache
      trackRecords: { data: null, timestamp: 0, ttl: 5000 },   // 5s cache - changes less frequently
      topMMR: { data: null, timestamp: 0, ttl: 5000 },         // 5s cache
      topSR: { data: null, timestamp: 0, ttl: 5000 },          // 5s cache
      sessionsCount: { data: null, timestamp: 0, ttl: 10000 }, // 10s cache - rarely changes
      recentSessions: { data: null, timestamp: 0, ttl: 2500 }, // 2.5s cache
    };
  }

  // Helper to get cached query result or run query
  async _cachedQuery(cacheKey, queryFn) {
    const cache = this._queryCache[cacheKey];
    const now = Date.now();
    if (cache && cache.data && (now - cache.timestamp) < cache.ttl) {
      return cache.data;
    }
    const result = await queryFn();
    if (cache) {
      cache.data = result;
      cache.timestamp = now;
    }
    return result;
  }

  // Invalidate cache when data changes
  _invalidateCache(cacheKey) {
    if (this._queryCache[cacheKey]) {
      this._queryCache[cacheKey].data = null;
      this._queryCache[cacheKey].timestamp = 0;
    }
  }

  async initializeTables() {
    const client = await this.pool.connect();
    try {
      await client.query(`
        CREATE TABLE IF NOT EXISTS players (
          guid TEXT PRIMARY KEY,
          "displayName" TEXT NOT NULL,
          "displayNameLower" TEXT NOT NULL,
          mmr INTEGER DEFAULT 1000,
          "safetyRating" REAL DEFAULT 0.5,
          "totalRaces" INTEGER DEFAULT 0,
          wins INTEGER DEFAULT 0,
          podiums INTEGER DEFAULT 0,
          holeshots INTEGER DEFAULT 0,
          "raceNumber" INTEGER DEFAULT 0,
          "bikeName" TEXT,
          "currentServer" TEXT,
          "currentTrack" TEXT,
          "lastSeen" BIGINT,
          "firstSeen" BIGINT,
          "autoGenerated" BOOLEAN DEFAULT FALSE,
          "updatedAt" BIGINT,
          "isBanned" BOOLEAN DEFAULT FALSE,
          "banReason" TEXT,
          "banExpiry" BIGINT,
          notes TEXT,
          "steamAvatarUrl" TEXT,
          "steamAvatarUpdated" BIGINT,
          "totalPlaytime" BIGINT DEFAULT 0
        )
      `);

      await client.query(`
        CREATE INDEX IF NOT EXISTS idx_players_mmr ON players(mmr DESC);
        CREATE INDEX IF NOT EXISTS idx_players_sr ON players("safetyRating" DESC);
        CREATE INDEX IF NOT EXISTS idx_players_lastseen ON players("lastSeen" DESC);
        CREATE INDEX IF NOT EXISTS idx_players_namelower ON players("displayNameLower");
      `);

      await client.query(`
        CREATE TABLE IF NOT EXISTS sessions (
          id TEXT PRIMARY KEY,
          "serverId" TEXT NOT NULL,
          "serverName" TEXT NOT NULL,
          "trackName" TEXT NOT NULL,
          "eventName" TEXT DEFAULT '',
          "sessionType" TEXT DEFAULT 'session',
          "currentSessionPhase" TEXT DEFAULT 'warmup',
          "sessionState" TEXT DEFAULT 'WAITING',
          "weatherConditions" TEXT DEFAULT 'Clear',
          "airTemperature" REAL DEFAULT 0,
          "trackLength" REAL DEFAULT 0,
          "startTime" BIGINT,
          "endTime" BIGINT,
          "warmupResults" JSONB DEFAULT '[]'::jsonb,
          "raceResults" JSONB DEFAULT '[]'::jsonb,
          "totalEntries" INTEGER DEFAULT 0,
          "hasFinished" BOOLEAN DEFAULT FALSE,
          "raceFinalized" BOOLEAN DEFAULT FALSE,
          "isActive" BOOLEAN DEFAULT TRUE,
          "createdAt" BIGINT
        )
      `);

      await client.query(`
        CREATE INDEX IF NOT EXISTS idx_sessions_created ON sessions("createdAt" DESC);
        CREATE INDEX IF NOT EXISTS idx_sessions_active ON sessions("isActive") WHERE "isActive" = TRUE;
        CREATE INDEX IF NOT EXISTS idx_sessions_finalized ON sessions("raceFinalized", "totalEntries", "startTime" DESC) WHERE "raceFinalized" = TRUE AND "totalEntries" > 0;
        CREATE INDEX IF NOT EXISTS idx_sessions_starttime ON sessions("startTime" DESC);
      `);

      await client.query(`
        CREATE TABLE IF NOT EXISTS player_sessions (
          "playerGuid" TEXT NOT NULL,
          "sessionId" TEXT NOT NULL,
          position INTEGER DEFAULT 0,
          "bestLapTime" REAL DEFAULT 0,
          "totalLaps" INTEGER DEFAULT 0,
          "didFinish" BOOLEAN DEFAULT FALSE,
          "mmrChange" INTEGER DEFAULT 0,
          "srChange" REAL DEFAULT 0,
          PRIMARY KEY ("playerGuid", "sessionId")
        )
      `);

      await client.query(`
        CREATE TABLE IF NOT EXISTS track_records (
          id TEXT PRIMARY KEY,
          "playerGuid" TEXT NOT NULL,
          "playerName" TEXT NOT NULL,
          "trackName" TEXT NOT NULL,
          "lapTime" REAL NOT NULL,
          "bikeName" TEXT,
          "serverName" TEXT DEFAULT '',
          "sessionId" TEXT,
          "sessionType" TEXT DEFAULT 'live',
          "setAt" BIGINT
        )
      `);

      await client.query(`
        CREATE INDEX IF NOT EXISTS idx_track_records_track ON track_records("trackName", "lapTime" ASC);
        CREATE INDEX IF NOT EXISTS idx_track_records_player ON track_records("playerGuid");
      `);

      // Migration: Add bikeCategory column for MXBMRP3 integration
      await client.query(`
        ALTER TABLE track_records ADD COLUMN IF NOT EXISTS "bikeCategory" TEXT;
      `).catch(() => {});

      await client.query(`
        CREATE TABLE IF NOT EXISTS contacts (
          id TEXT PRIMARY KEY,
          "sessionId" TEXT NOT NULL,
          time REAL NOT NULL,
          "playerGuid1" TEXT,
          "playerName1" TEXT,
          "raceNumber1" INTEGER,
          "playerGuid2" TEXT,
          "playerName2" TEXT,
          "raceNumber2" INTEGER,
          "isWallContact" BOOLEAN DEFAULT FALSE,
          "relativeImpactVelocity" REAL,
          "createdAt" BIGINT
        )
      `);

      await client.query(`
        CREATE TABLE IF NOT EXISTS holeshots (
          id TEXT PRIMARY KEY,
          "sessionId" TEXT NOT NULL,
          "playerGuid" TEXT NOT NULL,
          "playerName" TEXT NOT NULL,
          "raceNumber" INTEGER DEFAULT 0,
          "holeshotTime" REAL NOT NULL,
          "trackName" TEXT,
          "createdAt" BIGINT
        )
      `);

      await client.query(`
        CREATE TABLE IF NOT EXISTS leader_election (
          id TEXT PRIMARY KEY DEFAULT 'primary',
          machine_id TEXT NOT NULL,
          last_heartbeat BIGINT NOT NULL,
          acquired_at BIGINT NOT NULL
        )
      `);

      // Ban history table - tracks all bans and unbans
      await client.query(`
        CREATE TABLE IF NOT EXISTS ban_history (
          id TEXT PRIMARY KEY,
          "playerGuid" TEXT NOT NULL,
          "playerName" TEXT NOT NULL,
          action TEXT NOT NULL,
          reason TEXT,
          duration INTEGER,
          "durationType" TEXT,
          "isGlobal" BOOLEAN DEFAULT FALSE,
          "isPermanent" BOOLEAN DEFAULT FALSE,
          "expiresAt" BIGINT,
          "performedBy" TEXT DEFAULT 'System',
          "sourceManager" TEXT,
          "serverName" TEXT,
          "createdAt" BIGINT NOT NULL
        )
      `);

      await client.query(`
        CREATE INDEX IF NOT EXISTS idx_ban_history_player ON ban_history("playerGuid");
        CREATE INDEX IF NOT EXISTS idx_ban_history_created ON ban_history("createdAt" DESC);
      `);

      // Migration: Add serverName column if it doesn't exist
      await client.query(`
        ALTER TABLE ban_history ADD COLUMN IF NOT EXISTS "serverName" TEXT;
      `).catch(() => {}); // Ignore if column exists or alter fails

      // Migration: Add evidenceUrl column for storing video evidence from reports
      await client.query(`
        ALTER TABLE ban_history ADD COLUMN IF NOT EXISTS "evidenceUrl" TEXT;
      `).catch(() => {}); // Ignore if column exists or alter fails

      // Ban Appeals table
      await client.query(`
        CREATE TABLE IF NOT EXISTS ban_appeals (
          id TEXT PRIMARY KEY,
          "appealIndex" SERIAL,
          "playerGuid" TEXT NOT NULL,
          "playerName" TEXT NOT NULL,
          "userId" TEXT NOT NULL,
          "banReason" TEXT,
          "banDate" BIGINT,
          "banExpiry" BIGINT,
          "isPermanent" BOOLEAN DEFAULT FALSE,
          "serverName" TEXT,
          "isGlobal" BOOLEAN DEFAULT FALSE,
          "appealReason" TEXT NOT NULL,
          "additionalInfo" TEXT,
          "videoUrl" TEXT,
          status TEXT DEFAULT 'open',
          "claimedBy" TEXT,
          "claimedAt" BIGINT,
          "resolvedBy" TEXT,
          "resolvedAt" BIGINT,
          resolution TEXT,
          "cooldownUntil" BIGINT,
          "createdAt" BIGINT NOT NULL,
          "updatedAt" BIGINT
        )
      `);

      // Add videoUrl column if it doesn't exist (for existing databases)
      await client.query(`
        ALTER TABLE ban_appeals ADD COLUMN IF NOT EXISTS "videoUrl" TEXT
      `);

      // Add claimedByGuid and resolvedByGuid columns for admin avatar display
      await client.query(`
        ALTER TABLE ban_appeals ADD COLUMN IF NOT EXISTS "claimedByGuid" TEXT
      `);
      await client.query(`
        ALTER TABLE ban_appeals ADD COLUMN IF NOT EXISTS "resolvedByGuid" TEXT
      `);

      await client.query(`
        CREATE INDEX IF NOT EXISTS idx_ban_appeals_user ON ban_appeals("userId");
        CREATE INDEX IF NOT EXISTS idx_ban_appeals_player ON ban_appeals("playerGuid");
        CREATE INDEX IF NOT EXISTS idx_ban_appeals_status ON ban_appeals(status);
        CREATE INDEX IF NOT EXISTS idx_ban_appeals_created ON ban_appeals("createdAt" DESC);
      `);

      // Player Reports table
      await client.query(`
        CREATE TABLE IF NOT EXISTS player_reports (
          id TEXT PRIMARY KEY,
          "reportIndex" SERIAL,
          "reporterGuid" TEXT NOT NULL,
          "reporterName" TEXT NOT NULL,
          "reporterUserId" TEXT NOT NULL,
          "offenderGuid" TEXT NOT NULL,
          "offenderName" TEXT NOT NULL,
          "serverName" TEXT,
          reason TEXT NOT NULL,
          description TEXT NOT NULL,
          "videoUrl" TEXT NOT NULL,
          status TEXT DEFAULT 'open',
          "claimedBy" TEXT,
          "claimedAt" BIGINT,
          "resolvedBy" TEXT,
          "resolvedAt" BIGINT,
          resolution TEXT,
          "actionTaken" TEXT,
          "createdAt" BIGINT NOT NULL,
          "updatedAt" BIGINT
        )
      `);

      await client.query(`
        CREATE INDEX IF NOT EXISTS idx_player_reports_user ON player_reports("reporterUserId");
        CREATE INDEX IF NOT EXISTS idx_player_reports_offender ON player_reports("offenderGuid");
        CREATE INDEX IF NOT EXISTS idx_player_reports_status ON player_reports(status);
        CREATE INDEX IF NOT EXISTS idx_player_reports_created ON player_reports("createdAt" DESC);
      `);

      // Add claimedByGuid and resolvedByGuid columns for admin avatar display
      await client.query(`
        ALTER TABLE player_reports ADD COLUMN IF NOT EXISTS "claimedByGuid" TEXT
      `);
      await client.query(`
        ALTER TABLE player_reports ADD COLUMN IF NOT EXISTS "resolvedByGuid" TEXT
      `);

      // Notifications table
      await client.query(`
        CREATE TABLE IF NOT EXISTS notifications (
          id TEXT PRIMARY KEY,
          "userId" TEXT NOT NULL,
          type TEXT NOT NULL,
          title TEXT NOT NULL,
          message TEXT NOT NULL,
          link TEXT,
          read BOOLEAN DEFAULT FALSE,
          "relatedId" TEXT,
          "createdAt" BIGINT NOT NULL
        )
      `);

      await client.query(`
        CREATE INDEX IF NOT EXISTS idx_notifications_user ON notifications("userId");
        CREATE INDEX IF NOT EXISTS idx_notifications_read ON notifications("userId", read) WHERE read = FALSE;
        CREATE INDEX IF NOT EXISTS idx_notifications_created ON notifications("createdAt" DESC);
      `);

      // Migration: Add relatedId column if it doesn't exist (for existing databases)
      try {
        await client.query(`ALTER TABLE notifications ADD COLUMN IF NOT EXISTS "relatedId" TEXT`);
        await client.query(`CREATE INDEX IF NOT EXISTS idx_notifications_related ON notifications("relatedId")`);
      } catch (migrationErr) {
        console.log('[POSTGRES] relatedId migration:', migrationErr.message);
      }

      // Player Warnings table
      await client.query(`
        CREATE TABLE IF NOT EXISTS player_warnings (
          id TEXT PRIMARY KEY,
          "playerGuid" TEXT NOT NULL,
          "playerName" TEXT NOT NULL,
          reason TEXT NOT NULL,
          "warnedBy" TEXT NOT NULL,
          "reportId" TEXT,
          "createdAt" BIGINT NOT NULL,
          acknowledged BOOLEAN DEFAULT FALSE,
          "acknowledgedAt" BIGINT
        )
      `);

      await client.query(`
        CREATE INDEX IF NOT EXISTS idx_player_warnings_player ON player_warnings("playerGuid");
        CREATE INDEX IF NOT EXISTS idx_player_warnings_created ON player_warnings("createdAt" DESC);
      `);

      // Migration: Add warnedByGuid column
      try {
        await client.query(`ALTER TABLE player_warnings ADD COLUMN IF NOT EXISTS "warnedByGuid" TEXT`);
      } catch (migrationErr) {
        console.log('[POSTGRES] warnedByGuid migration:', migrationErr.message);
      }

      // Migration: Add acknowledged columns if they don't exist
      try {
        await client.query(`ALTER TABLE player_warnings ADD COLUMN IF NOT EXISTS acknowledged BOOLEAN DEFAULT FALSE`);
        await client.query(`ALTER TABLE player_warnings ADD COLUMN IF NOT EXISTS "acknowledgedAt" BIGINT`);
      } catch (migrationErr) {
        console.log('[POSTGRES] player_warnings migration:', migrationErr.message);
      }

      // Announcements table
      await client.query(`
        CREATE TABLE IF NOT EXISTS announcements (
          id TEXT PRIMARY KEY,
          title TEXT NOT NULL,
          message TEXT NOT NULL,
          type TEXT DEFAULT 'info',
          active BOOLEAN DEFAULT TRUE,
          "createdBy" TEXT NOT NULL,
          "createdByName" TEXT,
          "createdAt" BIGINT NOT NULL,
          "updatedAt" BIGINT,
          "expiresAt" BIGINT
        )
      `);

      await client.query(`
        CREATE INDEX IF NOT EXISTS idx_announcements_active ON announcements(active) WHERE active = TRUE;
        CREATE INDEX IF NOT EXISTS idx_announcements_created ON announcements("createdAt" DESC);
      `);

      // Migration: Add Steam avatar columns if they don't exist (for existing databases)
      try {
        await client.query(`ALTER TABLE players ADD COLUMN IF NOT EXISTS "steamAvatarUrl" TEXT`);
        await client.query(`ALTER TABLE players ADD COLUMN IF NOT EXISTS "steamAvatarUpdated" BIGINT`);
        console.log('[POSTGRES] Steam avatar columns migration complete');
      } catch (migrationErr) {
        console.log('[POSTGRES] Steam avatar migration:', migrationErr.message);
      }

      // Migration: Add totalPlaytime column for tracking player playtime
      try {
        await client.query(`ALTER TABLE players ADD COLUMN IF NOT EXISTS "totalPlaytime" BIGINT DEFAULT 0`);
        console.log('[POSTGRES] totalPlaytime column migration complete');
      } catch (migrationErr) {
        console.log('[POSTGRES] totalPlaytime migration:', migrationErr.message);
      }

      // Migration: Add investigation columns for admin player management
      try {
        await client.query(`ALTER TABLE players ADD COLUMN IF NOT EXISTS "underInvestigation" BOOLEAN DEFAULT FALSE`);
        await client.query(`ALTER TABLE players ADD COLUMN IF NOT EXISTS "investigationReason" TEXT`);
        await client.query(`ALTER TABLE players ADD COLUMN IF NOT EXISTS "investigationBy" TEXT`);
        await client.query(`ALTER TABLE players ADD COLUMN IF NOT EXISTS "investigationDate" BIGINT`);
        await client.query(`ALTER TABLE players ADD COLUMN IF NOT EXISTS "frozenMMR" INTEGER`);  // Stores original MMR when frozen
        console.log('[POSTGRES] Investigation columns migration complete');
      } catch (migrationErr) {
        console.log('[POSTGRES] Investigation migration:', migrationErr.message);
      }

      // Feature Requests table - for admin feature/bug requests to developer
      await client.query(`
        CREATE TABLE IF NOT EXISTS feature_requests (
          id TEXT PRIMARY KEY,
          "requestIndex" SERIAL,
          title TEXT NOT NULL,
          description TEXT NOT NULL,
          type TEXT DEFAULT 'feature',
          status TEXT DEFAULT 'pending',
          "submittedBy" TEXT NOT NULL,
          "submittedByName" TEXT NOT NULL,
          "submittedByGuid" TEXT,
          "developerComment" TEXT,
          upvotes TEXT[] DEFAULT '{}',
          downvotes TEXT[] DEFAULT '{}',
          "createdAt" BIGINT NOT NULL,
          "updatedAt" BIGINT
        )
      `);

      await client.query(`
        CREATE INDEX IF NOT EXISTS idx_feature_requests_status ON feature_requests(status);
        CREATE INDEX IF NOT EXISTS idx_feature_requests_created ON feature_requests("createdAt" DESC);
      `);

      // Support Tickets table (General Issues / Other)
      await client.query(`
        CREATE TABLE IF NOT EXISTS support_tickets (
          id TEXT PRIMARY KEY,
          "userId" TEXT NOT NULL,
          "userEmail" TEXT,
          "reporterGuid" TEXT,
          "reporterName" TEXT,
          "issueType" TEXT NOT NULL,
          subject TEXT NOT NULL,
          description TEXT NOT NULL,
          status TEXT DEFAULT 'pending',
          resolution TEXT,
          "resolvedBy" TEXT,
          "resolvedAt" BIGINT,
          "createdAt" BIGINT NOT NULL,
          "updatedAt" BIGINT
        )
      `);

      await client.query(`
        CREATE INDEX IF NOT EXISTS idx_support_tickets_user ON support_tickets("userId");
        CREATE INDEX IF NOT EXISTS idx_support_tickets_status ON support_tickets(status);
        CREATE INDEX IF NOT EXISTS idx_support_tickets_created ON support_tickets("createdAt" DESC);
      `);

      // Migration: Add missing columns to support_tickets if they don't exist
      try {
        await client.query(`ALTER TABLE support_tickets ADD COLUMN IF NOT EXISTS "reporterGuid" TEXT`);
        await client.query(`ALTER TABLE support_tickets ADD COLUMN IF NOT EXISTS "reporterName" TEXT`);
        await client.query(`ALTER TABLE support_tickets ADD COLUMN IF NOT EXISTS "issueType" TEXT`);
        await client.query(`ALTER TABLE support_tickets ADD COLUMN IF NOT EXISTS resolution TEXT`);
        await client.query(`ALTER TABLE support_tickets ADD COLUMN IF NOT EXISTS "resolvedBy" TEXT`);
        await client.query(`ALTER TABLE support_tickets ADD COLUMN IF NOT EXISTS "resolvedByGuid" TEXT`);
        await client.query(`ALTER TABLE support_tickets ADD COLUMN IF NOT EXISTS "resolvedAt" BIGINT`);
      } catch (migrationErr) {
        console.log('[POSTGRES] support_tickets migration:', migrationErr.message);
      }

      // Message Templates table (for ban/unban/warn/kick messages)
      await client.query(`
        CREATE TABLE IF NOT EXISTS message_templates (
          id TEXT PRIMARY KEY DEFAULT 'default',
          "banPrivateMessageEnabled" BOOLEAN DEFAULT true,
          "banPrivateMessageTemplate" TEXT DEFAULT 'You have been banned for {duration}. Reason: {reason}',
          "banGlobalMessageEnabled" BOOLEAN DEFAULT true,
          "banGlobalMessageTemplate" TEXT DEFAULT '{name} has been banned for {duration}. Reason: {reason}',
          "unbanMessageEnabled" BOOLEAN DEFAULT true,
          "unbanMessageTemplate" TEXT DEFAULT '{name} has been unbanned',
          "warningMessageEnabled" BOOLEAN DEFAULT true,
          "warningMessageTemplate" TEXT DEFAULT 'WARNING: {reason}',
          "warningGlobalMessageEnabled" BOOLEAN DEFAULT true,
          "warningGlobalMessageTemplate" TEXT DEFAULT '{name} has received a warning: {reason}',
          "kickPrivateMessageEnabled" BOOLEAN DEFAULT true,
          "kickPrivateMessageTemplate" TEXT DEFAULT 'You have been kicked. Reason: {reason}',
          "kickGlobalMessageEnabled" BOOLEAN DEFAULT true,
          "kickGlobalMessageTemplate" TEXT DEFAULT '{name} has been kicked. Reason: {reason}',
          "updatedAt" BIGINT
        )
      `);

      // Insert default row if not exists
      await client.query(`
        INSERT INTO message_templates (id) VALUES ('default')
        ON CONFLICT (id) DO NOTHING
      `);

      // Automated Messages table
      await client.query(`
        CREATE TABLE IF NOT EXISTS automated_messages (
          id TEXT PRIMARY KEY,
          message TEXT NOT NULL,
          "intervalMinutes" INTEGER NOT NULL DEFAULT 5,
          "isEnabled" BOOLEAN DEFAULT true,
          "isGlobal" BOOLEAN DEFAULT false,
          "serverId" TEXT,
          "serverName" TEXT,
          "lastSent" BIGINT,
          "createdAt" BIGINT NOT NULL,
          "updatedAt" BIGINT
        )
      `);

      await client.query(`
        CREATE INDEX IF NOT EXISTS idx_automated_messages_enabled ON automated_messages("isEnabled");
        CREATE INDEX IF NOT EXISTS idx_automated_messages_server ON automated_messages("serverId");
      `);

      console.log('[POSTGRES] All tables initialized successfully');
    } finally {
      client.release();
    }
  }

  async upsertPlayer(player) {
    const now = Date.now();
    const displayName = player.displayName || `Player_${player.guid.slice(-8)}`;

    await this.pool.query(`
      INSERT INTO players (guid, "displayName", "displayNameLower", mmr, "safetyRating",
        "totalRaces", wins, podiums, "raceNumber", "bikeName", "currentServer", "currentTrack",
        "lastSeen", "firstSeen", "autoGenerated", "updatedAt")
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)
      ON CONFLICT (guid) DO UPDATE SET
        "displayName" = EXCLUDED."displayName",
        "displayNameLower" = EXCLUDED."displayNameLower",
        "raceNumber" = EXCLUDED."raceNumber",
        "bikeName" = EXCLUDED."bikeName",
        "currentServer" = EXCLUDED."currentServer",
        "currentTrack" = EXCLUDED."currentTrack",
        "lastSeen" = EXCLUDED."lastSeen",
        "updatedAt" = EXCLUDED."updatedAt"
    `, [
      player.guid,
      displayName,
      displayName.toLowerCase(),
      player.mmr || 1000,
      player.safetyRating || 0.5,
      player.totalRaces || 0,
      player.wins || 0,
      player.podiums || 0,
      player.raceNumber || 0,
      player.bikeName || null,
      player.currentServer || null,
      player.currentTrack || null,
      player.lastSeen || now,
      player.firstSeen || now,
      player.autoGenerated || false,
      now
    ]);
  }

  async batchUpsertPlayers(players, playtimeIncrement = 60000) {
    if (players.length === 0) return;

    const now = Date.now();
    const client = await this.pool.connect();

    try {
      const guids = [];
      const displayNames = [];
      const displayNamesLower = [];
      const mmrs = [];
      const safetyRatings = [];
      const totalRaces = [];
      const wins = [];
      const podiums = [];
      const raceNumbers = [];
      const bikeNames = [];
      const currentServers = [];
      const currentTracks = [];
      const lastSeens = [];
      const firstSeens = [];
      const autoGenerateds = [];
      const updatedAts = [];

      for (const player of players) {
        const displayName = player.displayName || `Player_${player.guid.slice(-8)}`;
        guids.push(player.guid);
        displayNames.push(displayName);
        displayNamesLower.push(displayName.toLowerCase());
        mmrs.push(player.mmr || 1000);
        safetyRatings.push(player.safetyRating || 0.5);
        totalRaces.push(player.totalRaces || 0);
        wins.push(player.wins || 0);
        podiums.push(player.podiums || 0);
        raceNumbers.push(player.raceNumber || 0);
        bikeNames.push(player.bikeName || null);
        currentServers.push(player.currentServer || null);
        currentTracks.push(player.currentTrack || null);
        lastSeens.push(player.lastSeen || now);
        firstSeens.push(player.firstSeen || now);
        autoGenerateds.push(player.autoGenerated || false);
        updatedAts.push(now);
      }

      // Use individual updates to properly increment playtime
      // Only increment playtime when lastSeen changes (player is online)
      await client.query('BEGIN');

      for (let i = 0; i < guids.length; i++) {
        await client.query(`
          INSERT INTO players (
            guid, "displayName", "displayNameLower", mmr, "safetyRating",
            "totalRaces", wins, podiums, "raceNumber", "bikeName", "currentServer", "currentTrack",
            "lastSeen", "firstSeen", "autoGenerated", "updatedAt", "totalPlaytime"
          )
          VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, 0)
          ON CONFLICT (guid) DO UPDATE SET
            "displayName" = EXCLUDED."displayName",
            "displayNameLower" = EXCLUDED."displayNameLower",
            "raceNumber" = EXCLUDED."raceNumber",
            "bikeName" = EXCLUDED."bikeName",
            "currentServer" = EXCLUDED."currentServer",
            "currentTrack" = EXCLUDED."currentTrack",
            "lastSeen" = EXCLUDED."lastSeen",
            "updatedAt" = EXCLUDED."updatedAt",
            "totalPlaytime" = COALESCE(players."totalPlaytime", 0) + $17
        `, [
          guids[i], displayNames[i], displayNamesLower[i], mmrs[i], safetyRatings[i],
          totalRaces[i], wins[i], podiums[i], raceNumbers[i], bikeNames[i],
          currentServers[i], currentTracks[i], lastSeens[i], firstSeens[i],
          autoGenerateds[i], updatedAts[i], playtimeIncrement
        ]);
      }

      await client.query('COMMIT');

      // Invalidate player caches after update
      this._invalidateCache('playersSlim');

    } catch (err) {
      await client.query('ROLLBACK');
      throw err;
    } finally {
      client.release();
    }
  }

  async getPlayer(guid) {
    // Calculate actual race count from session data to ensure accuracy
    // Match any session type containing 'race' (race1, race2, RACE1, RACE2, etc.)
    const result = await this.pool.query(`
      SELECT p.*,
        COALESCE(race_count.count, 0) as "actualTotalRaces",
        COALESCE(win_count.count, 0) as "actualWins",
        COALESCE(podium_count.count, 0) as "actualPodiums"
      FROM players p
      LEFT JOIN (
        SELECT ps."playerGuid", COUNT(*) as count
        FROM player_sessions ps
        INNER JOIN sessions s ON s.id = ps."sessionId"
        WHERE LOWER(s."sessionType") LIKE '%race%'
        GROUP BY ps."playerGuid"
      ) race_count ON race_count."playerGuid" = p.guid
      LEFT JOIN (
        SELECT ps."playerGuid", COUNT(*) as count
        FROM player_sessions ps
        INNER JOIN sessions s ON s.id = ps."sessionId"
        WHERE LOWER(s."sessionType") LIKE '%race%' AND ps.position = 1
        GROUP BY ps."playerGuid"
      ) win_count ON win_count."playerGuid" = p.guid
      LEFT JOIN (
        SELECT ps."playerGuid", COUNT(*) as count
        FROM player_sessions ps
        INNER JOIN sessions s ON s.id = ps."sessionId"
        WHERE LOWER(s."sessionType") LIKE '%race%' AND ps.position <= 3
        GROUP BY ps."playerGuid"
      ) podium_count ON podium_count."playerGuid" = p.guid
      WHERE p.guid = $1
    `, [guid]);

    if (result.rows.length === 0) return null;

    const row = result.rows[0];
    const player = this.rowToPlayer(row);
    // Override with actual counts from session data (use calculated values, not stored)
    const actualRaces = parseInt(row.actualTotalRaces);
    const actualWins = parseInt(row.actualWins);
    const actualPodiums = parseInt(row.actualPodiums);
    player.totalRaces = !isNaN(actualRaces) ? actualRaces : player.totalRaces;
    player.wins = !isNaN(actualWins) ? actualWins : player.wins;
    player.podiums = !isNaN(actualPodiums) ? actualPodiums : player.podiums;
    return player;
  }

  // Get ALL players (for backwards compatibility) - use getRecentPlayers for bulk endpoint
  async getAllPlayers() {
    const result = await this.pool.query('SELECT * FROM players ORDER BY "lastSeen" DESC');
    return result.rows.map(row => this.rowToPlayer(row));
  }

  // Get recent/active players only - much faster for bulk endpoint
  async getRecentPlayers(limit = 1000) {
    const result = await this.pool.query(
      'SELECT * FROM players ORDER BY "lastSeen" DESC LIMIT $1',
      [limit]
    );
    return result.rows.map(row => this.rowToPlayer(row));
  }

  // Search players by name (for Players page search)
  async searchPlayers(query, limit = 100) {
    const searchTerm = `%${query.toLowerCase()}%`;
    const result = await this.pool.query(
      `SELECT * FROM players
       WHERE "displayNameLower" LIKE $1 OR guid ILIKE $1
       ORDER BY "lastSeen" DESC
       LIMIT $2`,
      [searchTerm, limit]
    );
    return result.rows.map(row => this.rowToPlayer(row));
  }

  async getTotalPlayersCount() {
    const result = await this.pool.query('SELECT COUNT(*) as count FROM players');
    return parseInt(result.rows[0].count);
  }

  async getBatchPlayers(guids) {
    if (guids.length === 0) return [];
    const placeholders = guids.map((_, i) => `$${i + 1}`).join(',');
    const result = await this.pool.query(
      `SELECT * FROM players WHERE guid IN (${placeholders})`,
      guids
    );
    return result.rows.map(row => this.rowToPlayer(row));
  }

  async getTopPlayersByMMR(limit = 100) {
    // Only cache the default 100 limit (used by bulk endpoint)
    if (limit === 100) {
      return this._cachedQuery('topMMR', async () => {
        const result = await this.pool.query('SELECT * FROM players ORDER BY mmr DESC LIMIT $1', [limit]);
        return result.rows.map(row => this.rowToPlayer(row));
      });
    }
    const result = await this.pool.query('SELECT * FROM players ORDER BY mmr DESC LIMIT $1', [limit]);
    return result.rows.map(row => this.rowToPlayer(row));
  }

  async getTopPlayersBySR(limit = 100) {
    // Only cache the default 100 limit (used by bulk endpoint)
    if (limit === 100) {
      return this._cachedQuery('topSR', async () => {
        const result = await this.pool.query('SELECT * FROM players ORDER BY "safetyRating" DESC LIMIT $1', [limit]);
        return result.rows.map(row => this.rowToPlayer(row));
      });
    }
    const result = await this.pool.query('SELECT * FROM players ORDER BY "safetyRating" DESC LIMIT $1', [limit]);
    return result.rows.map(row => this.rowToPlayer(row));
  }

  async updatePlayerMMR(guid, mmrChange, srChange, won = false, podium = false) {
    await this.pool.query(`
      UPDATE players SET
        mmr = GREATEST(0, mmr + $1),
        "safetyRating" = LEAST(1.0, GREATEST(0.0, "safetyRating" + $2)),
        "totalRaces" = "totalRaces" + 1,
        wins = wins + $3,
        podiums = podiums + $4,
        "updatedAt" = $5
      WHERE guid = $6
    `, [mmrChange, srChange, won ? 1 : 0, podium ? 1 : 0, Date.now(), guid]);
  }

  // Reduce safety rating by a percentage (e.g., 0.15 for 15%)
  async reduceSafetyRating(guid, reduction = 0.15) {
    await this.pool.query(`
      UPDATE players SET
        "safetyRating" = GREATEST(0.0, "safetyRating" - $1),
        "updatedAt" = $2
      WHERE guid = $3
    `, [reduction, Date.now(), guid]);
    console.log(`[POSTGRES] Reduced safety rating for ${guid} by ${reduction * 100}%`);
  }

  calculateMMRChanges(raceResults) {
    const changes = [];
    const totalPlayers = raceResults.length;

    const holeshotWinner = raceResults
      .filter(r => r.holeshotTime && r.holeshotTime > 0)
      .sort((a, b) => a.holeshotTime - b.holeshotTime)[0];
    const holeshotGuid = holeshotWinner?.playerGuid;

    if (totalPlayers < 3) {
      for (let i = 0; i < raceResults.length; i++) {
        const player = raceResults[i];
        const srChange = this._calculateSafetyRating(player);
        changes.push({
          playerGuid: player.playerGuid,
          mmrChange: 0,
          srChange,
          won: i === 0,
          podium: i < 3,
          gotHoleshot: player.playerGuid === holeshotGuid
        });
      }
      return changes;
    }

    let baseMMR = Math.pow(totalPlayers, 0.70) * 2.4;

    if (totalPlayers <= 5) {
      baseMMR *= 0.6;
    }

    const zeroPoint = Math.ceil(totalPlayers * 0.55);

    for (let i = 0; i < raceResults.length; i++) {
      const player = raceResults[i];
      const position = i + 1;
      let mmrChange = 0;

      // Calculate safety rating based on race performance and incidents
      let srChange = this._calculateSafetyRating(player);

      if (position < zeroPoint) {
        const positionFactor = Math.pow(
          (zeroPoint - position) / Math.max(1, zeroPoint - 1),
          1.2
        );
        mmrChange = Math.round(baseMMR * positionFactor);

        if (totalPlayers >= 10) {
          if (position === 1) mmrChange += 3;
          if (position === 2) mmrChange += 2;
          if (position === 3) mmrChange += 1;
        }
      } else if (position === zeroPoint) {
        mmrChange = 0;
      } else {
        const lossZone = totalPlayers - zeroPoint;
        const lossFactor = (position - zeroPoint) / lossZone;
        mmrChange = -Math.round((baseMMR * lossFactor) * 0.6);
      }

      changes.push({
        playerGuid: player.playerGuid,
        mmrChange,
        srChange,
        won: position === 1,
        podium: position <= 3,
        gotHoleshot: player.playerGuid === holeshotGuid
      });
    }

    return changes;
  }

  _calculateSafetyRating(player) {
    // SAFETY RATING SYSTEM v2.0
    // Designed with 30% auto-ban threshold in mind
    // Takes ~10-15 consistently reckless races to hit ban
    // Takes ~10 clean races to recover from 30% to 50%

    // Base reward for completing the race
    let srChange = 0.003; // 0.3% base completion bonus

    // Check if player retired/DNF
    const didNotFinish = player.driverStatus === 'RET' || player.driverStatus === 'DNS' || player.driverStatus === 'DSQ';
    if (didNotFinish) {
      // Penalty for not finishing (quitting/giving up)
      srChange = -0.015; // -1.5% for DNF/RET/DSQ
      console.log(`[SR] ${player.playerName}: DNF penalty -1.5%`);
      return srChange;
    }

    // Count contacts if available
    const contacts = player.contacts || [];
    const totalLaps = player.totalLaps || 1;

    // Categorize contacts by speed and type
    let lowSpeedWallContacts = 0;
    let mediumSpeedWallContacts = 0;
    let highSpeedWallContacts = 0;
    let bikeContactsTotal = 0;
    let lowSpeedBikeContacts = 0;
    let mediumSpeedBikeContacts = 0;
    let highSpeedBikeContacts = 0;

    for (const contact of contacts) {
      const speed = contact.relative_impact_velocity || 0;
      const isBikeContact = contact.race_number_1 > 0 && contact.race_number_2 > 0;

      if (isBikeContact) {
        bikeContactsTotal++;
        // Bike-to-bike contacts are MUCH more severe (dangerous racing)
        if (speed < 3) {
          lowSpeedBikeContacts++;
          srChange -= 0.001; // -0.1% per gentle bike contact (racing incident)
        } else if (speed < 8) {
          mediumSpeedBikeContacts++;
          srChange -= 0.004; // -0.4% per medium bike collision
        } else {
          highSpeedBikeContacts++;
          srChange -= 0.008; // -0.8% per dangerous high-speed bike collision
        }
      } else {
        // Wall contacts (less severe - only affects you)
        if (speed < 5) {
          lowSpeedWallContacts++;
          srChange -= 0.0005; // -0.05% per scrub/minor wall touch
        } else if (speed < 15) {
          mediumSpeedWallContacts++;
          srChange -= 0.0015; // -0.15% per wall crash
        } else {
          highSpeedWallContacts++;
          srChange -= 0.0025; // -0.25% per big wall crash
        }
      }
    }

    // Clean lap bonus (rewards consistent clean racing)
    const majorIncidents = mediumSpeedWallContacts + highSpeedWallContacts + bikeContactsTotal;
    const estimatedCleanLaps = Math.max(0, totalLaps - majorIncidents);
    const cleanLapBonus = estimatedCleanLaps * 0.0015; // +0.15% per clean lap
    srChange += cleanLapBonus;

    // Perfect race bonus (zero contacts, minimum 3 laps)
    if (contacts.length === 0 && totalLaps >= 3) {
      srChange += 0.012; // +1.2% bonus for flawless performance
    }

    // Invalid lap penalty (track cutting / shortcuts)
    const invalidLaps = player.invalidLaps || 0;
    if (invalidLaps > 0) {
      srChange -= invalidLaps * 0.002; // -0.2% per invalid lap
    }

    // Special case: Serial crasher detection (10+ contacts in a race)
    if (contacts.length >= 10) {
      const excessContacts = contacts.length - 10;
      srChange -= excessContacts * 0.001; // Additional -0.1% per contact over 10
      console.log(`[SR] ${player.playerName}: SERIAL CRASHER detected! ${contacts.length} contacts`);
    }

    // Cap safety rating change to prevent extreme swings
    // Max gain: +2.0% per race (perfect race on long track)
    // Max loss: -2.5% per race (extremely reckless)
    srChange = Math.max(-0.025, Math.min(0.020, srChange));

    // Detailed logging for transparency
    const totalWallContacts = lowSpeedWallContacts + mediumSpeedWallContacts + highSpeedWallContacts;
    console.log(`[SR] ${player.playerName}: SR ${(srChange * 100).toFixed(2)}% | Contacts: ${contacts.length} (${bikeContactsTotal} bike, ${totalWallContacts} wall) | Laps: ${totalLaps} (${estimatedCleanLaps} clean) | Invalid: ${invalidLaps}`);

    return srChange;
  }

  async batchUpdatePlayerMMR(changes) {
    if (changes.length === 0) return;

    const now = Date.now();
    const client = await this.pool.connect();

    try {
      await client.query('BEGIN');

      for (const change of changes) {
        await client.query(`
          UPDATE players SET
            mmr = GREATEST(0, mmr + $1),
            "safetyRating" = LEAST(1.0, GREATEST(0.0, "safetyRating" + $2)),
            "totalRaces" = "totalRaces" + 1,
            wins = wins + $3,
            podiums = podiums + $4,
            holeshots = holeshots + $5,
            "updatedAt" = $6
          WHERE guid = $7
        `, [
          change.mmrChange,
          change.srChange,
          change.won ? 1 : 0,
          change.podium ? 1 : 0,
          change.gotHoleshot ? 1 : 0,
          now,
          change.playerGuid
        ]);
      }

      await client.query('COMMIT');

      // Invalidate player and leaderboard caches after MMR update
      this._invalidateCache('playersSlim');
      this._invalidateCache('topMMR');
      this._invalidateCache('topSR');

    } catch (err) {
      await client.query('ROLLBACK');
      throw err;
    } finally {
      client.release();
    }
  }

  // Put player under investigation - saves their MMR and sets it to 1
  async investigatePlayer(guid, reason, adminName) {
    const player = await this.getPlayer(guid);
    if (!player) throw new Error('Player not found');

    if (player.underInvestigation) {
      throw new Error('Player is already under investigation');
    }

    await this.pool.query(`
      UPDATE players SET
        "underInvestigation" = TRUE,
        "investigationReason" = $1,
        "investigationBy" = $2,
        "investigationDate" = $3,
        "frozenMMR" = mmr,
        mmr = 1,
        "updatedAt" = $3
      WHERE guid = $4
    `, [reason, adminName, Date.now(), guid]);

    // Invalidate caches
    this._invalidateCache('playersSlim');
    this._invalidateCache('topMMR');

    return { originalMMR: player.mmr };
  }

  // Restore player from investigation - gives back their original MMR
  async restorePlayer(guid) {
    const player = await this.getPlayer(guid);
    if (!player) throw new Error('Player not found');

    if (!player.underInvestigation) {
      throw new Error('Player is not under investigation');
    }

    const originalMMR = player.frozenMMR || 1000;

    await this.pool.query(`
      UPDATE players SET
        "underInvestigation" = FALSE,
        "investigationReason" = NULL,
        "investigationBy" = NULL,
        "investigationDate" = NULL,
        mmr = $1,
        "frozenMMR" = NULL,
        "updatedAt" = $2
      WHERE guid = $3
    `, [originalMMR, Date.now(), guid]);

    // Invalidate caches
    this._invalidateCache('playersSlim');
    this._invalidateCache('topMMR');

    return { restoredMMR: originalMMR };
  }

  // Get all players under investigation
  async getPlayersUnderInvestigation() {
    const result = await this.pool.query(`
      SELECT guid, "displayName", "investigationReason", "investigationBy", "investigationDate", "frozenMMR"
      FROM players
      WHERE "underInvestigation" = TRUE
      ORDER BY "investigationDate" DESC
    `);
    return result.rows;
  }

  async getPlayerSessions(guid, limit = 20) {
    const result = await this.pool.query(`
      SELECT s.*, ps.position, ps."bestLapTime", ps."totalLaps", ps."didFinish", ps."mmrChange", ps."srChange"
      FROM sessions s
      INNER JOIN player_sessions ps ON s.id = ps."sessionId"
      WHERE ps."playerGuid" = $1
      ORDER BY s."createdAt" DESC
      LIMIT $2
    `, [guid, limit]);

    return result.rows.map(row => ({
      ...this.rowToSession(row),
      playerPosition: row.position,
      playerBestLap: row.bestLapTime,
      playerLaps: row.totalLaps,
      playerFinished: row.didFinish,
      mmrChange: row.mmrChange,
      srChange: row.srChange
    }));
  }

  async addPlayerToSession(sessionId, playerGuid, data) {
    await this.pool.query(`
      INSERT INTO player_sessions ("playerGuid", "sessionId", position, "bestLapTime", "totalLaps", "didFinish", "mmrChange", "srChange")
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
      ON CONFLICT ("playerGuid", "sessionId") DO UPDATE SET
        position = EXCLUDED.position,
        "bestLapTime" = EXCLUDED."bestLapTime",
        "totalLaps" = EXCLUDED."totalLaps",
        "didFinish" = EXCLUDED."didFinish",
        "mmrChange" = EXCLUDED."mmrChange",
        "srChange" = EXCLUDED."srChange"
    `, [
      playerGuid,
      sessionId,
      data.position || 0,
      data.bestLapTime || 0,
      data.totalLaps || 0,
      data.didFinish || false,
      data.mmrChange || 0,
      data.srChange || 0
    ]);
  }

  async batchAddPlayersToSession(sessionId, players) {
    if (players.length === 0) return;

    const client = await this.pool.connect();
    try {
      await client.query('BEGIN');

      for (const p of players) {
        await client.query(`
          INSERT INTO player_sessions ("playerGuid", "sessionId", position, "bestLapTime", "totalLaps", "didFinish", "mmrChange", "srChange")
          VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
          ON CONFLICT ("playerGuid", "sessionId") DO UPDATE SET
            position = EXCLUDED.position,
            "bestLapTime" = EXCLUDED."bestLapTime",
            "totalLaps" = EXCLUDED."totalLaps",
            "didFinish" = EXCLUDED."didFinish",
            "mmrChange" = EXCLUDED."mmrChange",
            "srChange" = EXCLUDED."srChange"
        `, [
          p.playerGuid,
          sessionId,
          p.position || 0,
          p.bestLapTime || 0,
          p.totalLaps || 0,
          p.didFinish || false,
          p.mmrChange || 0,
          p.srChange || 0
        ]);
      }

      await client.query('COMMIT');
    } catch (err) {
      await client.query('ROLLBACK');
      throw err;
    } finally {
      client.release();
    }
  }

  rowToPlayer(row) {
    return {
      guid: row.guid,
      displayName: row.displayName,
      mmr: row.mmr,
      safetyRating: row.safetyRating,
      totalRaces: row.totalRaces,
      wins: row.wins,
      podiums: row.podiums,
      holeshots: row.holeshots || 0,
      raceNumber: row.raceNumber,
      bikeName: row.bikeName,
      currentServer: row.currentServer,
      currentTrack: row.currentTrack,
      lastSeen: row.lastSeen ? parseInt(row.lastSeen) : null,
      firstSeen: row.firstSeen ? parseInt(row.firstSeen) : null,
      autoGenerated: row.autoGenerated,
      updatedAt: row.updatedAt ? parseInt(row.updatedAt) : null,
      isBanned: row.isBanned,
      banReason: row.banReason,
      banExpiry: row.banExpiry ? parseInt(row.banExpiry) : null,
      notes: row.notes,
      profileImageUrl: row.steamAvatarUrl || null,
      totalPlaytime: row.totalPlaytime ? parseInt(row.totalPlaytime) : 0,
      // Investigation fields
      underInvestigation: row.underInvestigation || false,
      investigationReason: row.investigationReason,
      investigationBy: row.investigationBy,
      investigationDate: row.investigationDate ? parseInt(row.investigationDate) : null,
      frozenMMR: row.frozenMMR
    };
  }

  // Slim player object for bulk endpoint - essential fields for search/display/avatars + Players page
  rowToPlayerSlim(row) {
    return {
      guid: row.guid,
      displayName: row.displayName,
      mmr: row.mmr,
      safetyRating: row.safetyRating,
      totalRaces: row.totalRaces,
      wins: row.wins,
      podiums: row.podiums,
      holeshots: row.holeshots,
      lastSeen: row.lastSeen ? parseInt(row.lastSeen) : null,
      firstSeen: row.firstSeen ? parseInt(row.firstSeen) : null,
      currentServer: row.currentServer,
      profileImageUrl: row.steamAvatarUrl || null,
      totalPlaytime: row.totalPlaytime ? parseInt(row.totalPlaytime) : 0,
      underInvestigation: row.underInvestigation || false
    };
  }

  // Get ALL players with slim data (for bulk endpoint - fast, small payload)
  async getAllPlayersSlim() {
    return this._cachedQuery('playersSlim', async () => {
      const result = await this.pool.query('SELECT guid, "displayName", mmr, "safetyRating", "totalRaces", wins, podiums, holeshots, "lastSeen", "firstSeen", "currentServer", "steamAvatarUrl", "totalPlaytime", "underInvestigation" FROM players ORDER BY "lastSeen" DESC');
      return result.rows.map(row => this.rowToPlayerSlim(row));
    });
  }

  // Update Steam avatar for a player
  async updatePlayerSteamAvatar(guid, avatarUrl) {
    await this.pool.query(
      `UPDATE players SET "steamAvatarUrl" = $1, "steamAvatarUpdated" = $2 WHERE guid = $3`,
      [avatarUrl, Date.now(), guid]
    );
  }

  // Batch update Steam avatars
  async batchUpdateSteamAvatars(avatarMap) {
    if (Object.keys(avatarMap).length === 0) return;
    const client = await this.pool.connect();
    try {
      await client.query('BEGIN');
      for (const [guid, avatarUrl] of Object.entries(avatarMap)) {
        await client.query(
          `UPDATE players SET "steamAvatarUrl" = $1, "steamAvatarUpdated" = $2 WHERE guid = $3`,
          [avatarUrl, Date.now(), guid]
        );
      }
      await client.query('COMMIT');
    } catch (err) {
      await client.query('ROLLBACK');
      throw err;
    } finally {
      client.release();
    }
  }

  // Get players needing avatar sync (no avatar or stale > 12 hours)
  async getPlayersNeedingAvatarSync(limit = 100) {
    const twelveHoursAgo = Date.now() - (12 * 60 * 60 * 1000); // 12 hours
    const result = await this.pool.query(`
      SELECT guid FROM players
      WHERE "steamAvatarUrl" IS NULL
         OR "steamAvatarUpdated" IS NULL
         OR "steamAvatarUpdated" < $1
      ORDER BY "lastSeen" DESC NULLS LAST
      LIMIT $2
    `, [twelveHoursAgo, limit]);
    return result.rows.map(r => r.guid);
  }

  async createSession(session) {
    const id = session.id || `${session.serverId}_${Date.now()}`;
    const now = Date.now();

    await this.pool.query(`
      INSERT INTO sessions (id, "serverId", "serverName", "trackName", "eventName", "sessionType",
        "currentSessionPhase", "sessionState", "weatherConditions", "airTemperature", "trackLength",
        "startTime", "warmupResults", "raceResults", "totalEntries", "hasFinished", "raceFinalized",
        "isActive", "createdAt")
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19)
    `, [
      id,
      session.serverId,
      session.serverName,
      session.trackName,
      session.eventName || '',
      session.sessionType || 'session',
      session.currentSessionPhase || 'warmup',
      session.sessionState || 'WAITING',
      session.weatherConditions || 'Clear',
      session.airTemperature || 0,
      session.trackLength || 0,
      session.startTime || now,
      JSON.stringify(session.warmupResults || []),
      JSON.stringify(session.raceResults || []),
      session.totalEntries || 0,
      session.hasFinished || false,
      session.raceFinalized || false,
      session.isActive !== false,
      now
    ]);

    return id;
  }

  async updateSession(id, updates) {
    const setParts = [];
    const values = [];
    let paramCount = 1;

    if (updates.warmupResults !== undefined) {
      setParts.push(`"warmupResults" = $${paramCount++}`);
      values.push(JSON.stringify(updates.warmupResults));
    }
    if (updates.raceResults !== undefined) {
      setParts.push(`"raceResults" = $${paramCount++}`);
      values.push(JSON.stringify(updates.raceResults));
    }
    if (updates.hasFinished !== undefined) {
      setParts.push(`"hasFinished" = $${paramCount++}`);
      values.push(updates.hasFinished);
    }
    if (updates.raceFinalized !== undefined) {
      setParts.push(`"raceFinalized" = $${paramCount++}`);
      values.push(updates.raceFinalized);
    }
    if (updates.isActive !== undefined) {
      setParts.push(`"isActive" = $${paramCount++}`);
      values.push(updates.isActive);
    }
    if (updates.endTime !== undefined) {
      setParts.push(`"endTime" = $${paramCount++}`);
      values.push(updates.endTime);
    }
    if (updates.currentSessionPhase !== undefined) {
      setParts.push(`"currentSessionPhase" = $${paramCount++}`);
      values.push(updates.currentSessionPhase);
    }
    if (updates.sessionState !== undefined) {
      setParts.push(`"sessionState" = $${paramCount++}`);
      values.push(updates.sessionState);
    }
    if (updates.totalEntries !== undefined) {
      setParts.push(`"totalEntries" = $${paramCount++}`);
      values.push(updates.totalEntries);
    }
    if (updates.trackName !== undefined) {
      setParts.push(`"trackName" = $${paramCount++}`);
      values.push(updates.trackName);
    }

    if (setParts.length === 0) return;

    values.push(id);
    await this.pool.query(
      `UPDATE sessions SET ${setParts.join(', ')} WHERE id = $${paramCount}`,
      values
    );

    // Invalidate session caches when sessions are finalized
    if (updates.raceFinalized || updates.hasFinished) {
      this._invalidateCache('recentSessions');
      this._invalidateCache('sessionsCount');
    }
  }

  async batchUpdateSessions(sessionUpdates) {
    if (sessionUpdates.length === 0) return;

    const client = await this.pool.connect();
    try {
      await client.query('BEGIN');

      for (const update of sessionUpdates) {
        await client.query(`
          UPDATE sessions SET
            "warmupResults" = $1,
            "totalEntries" = $2
          WHERE id = $3
        `, [
          JSON.stringify(update.updates.warmupResults),
          update.updates.totalEntries,
          update.sessionId
        ]);
      }

      await client.query('COMMIT');
    } catch (err) {
      await client.query('ROLLBACK');
      throw err;
    } finally {
      client.release();
    }
  }

  async getRecentSessions(limit = 50) {
    // Use UNION for better index utilization instead of OR
    const query = `
      (SELECT * FROM sessions WHERE "raceFinalized" = TRUE AND "totalEntries" > 0 ORDER BY "startTime" DESC LIMIT $1)
      UNION ALL
      (SELECT * FROM sessions WHERE "isActive" = TRUE ORDER BY "startTime" DESC LIMIT $1)
      ORDER BY "startTime" DESC
      LIMIT $1
    `;

    // Only cache the default 50 limit (used by bulk endpoint)
    if (limit === 50) {
      return this._cachedQuery('recentSessions', async () => {
        const result = await this.pool.query(query, [limit]);
        // Remove duplicates (a session could be both active and finalized briefly)
        const seen = new Set();
        return result.rows
          .filter(row => {
            if (seen.has(row.id)) return false;
            seen.add(row.id);
            return true;
          })
          .map(row => this.rowToSession(row));
      });
    }
    const result = await this.pool.query(query, [limit]);
    const seen = new Set();
    return result.rows
      .filter(row => {
        if (seen.has(row.id)) return false;
        seen.add(row.id);
        return true;
      })
      .map(row => this.rowToSession(row));
  }

  // Get ALL finalized sessions (for bulk endpoint - like getAllPlayers)
  async getAllFinalizedSessions() {
    const result = await this.pool.query(`
      SELECT * FROM sessions
      WHERE ("raceFinalized" = TRUE AND "totalEntries" > 0) OR "isActive" = TRUE
      ORDER BY "startTime" DESC
    `);
    return result.rows.map(row => this.rowToSession(row));
  }

  // Search sessions by player participation (uses player_sessions table)
  async searchSessionsByPlayer(playerGuid, limit = 100) {
    const result = await this.pool.query(`
      SELECT s.* FROM sessions s
      INNER JOIN player_sessions ps ON s.id = ps."sessionId"
      WHERE ps."playerGuid" = $1 AND s."raceFinalized" = TRUE
      ORDER BY s."startTime" DESC
      LIMIT $2
    `, [playerGuid.toUpperCase(), limit]);
    return result.rows.map(row => this.rowToSession(row));
  }

  async getSession(sessionId) {
    const result = await this.pool.query('SELECT * FROM sessions WHERE id = $1', [sessionId]);
    return result.rows.length > 0 ? this.rowToSession(result.rows[0]) : null;
  }

  async getActiveSessions() {
    const result = await this.pool.query(`
      SELECT * FROM sessions WHERE "isActive" = TRUE AND "hasFinished" = FALSE
    `);
    return result.rows.map(row => this.rowToSession(row));
  }

  async getTotalFinalizedSessionsCount() {
    return this._cachedQuery('sessionsCount', async () => {
      const result = await this.pool.query(`
        SELECT COUNT(*) as count FROM sessions
        WHERE "raceFinalized" = TRUE AND "totalEntries" > 0
      `);
      return parseInt(result.rows[0].count) || 0;
    });
  }

  rowToSession(row) {
    return {
      id: row.id,
      serverId: row.serverId,
      serverName: row.serverName,
      trackName: row.trackName,
      eventName: row.eventName,
      sessionType: row.sessionType,
      currentSessionPhase: row.currentSessionPhase,
      sessionState: row.sessionState,
      weatherConditions: row.weatherConditions,
      airTemperature: row.airTemperature,
      trackLength: row.trackLength,
      startTime: row.startTime ? parseInt(row.startTime) : null,
      endTime: row.endTime ? parseInt(row.endTime) : null,
      warmupResults: row.warmupResults || [],
      raceResults: row.raceResults || [],
      totalEntries: row.totalEntries,
      hasFinished: row.hasFinished,
      raceFinalized: row.raceFinalized,
      isActive: row.isActive,
      createdAt: row.createdAt ? parseInt(row.createdAt) : null
    };
  }

  async checkSinglePlayerPB(record) {
    const { playerGuid, playerName, trackName, lapTime, sessionType, bikeName, bikeCategory } = record;
    const id = `${playerGuid}_${trackName}`;
    const now = Date.now();

    const client = await this.pool.connect();
    try {
      const existingResult = await client.query(
        'SELECT "lapTime" FROM track_records WHERE id = $1',
        [id]
      );

      const existingPB = existingResult.rows.length > 0 ? existingResult.rows[0].lapTime : null;
      const isNewPB = !existingPB || lapTime < existingPB;

      if (isNewPB) {
        const improvement = existingPB ? existingPB - lapTime : 0;

        await client.query(`
          INSERT INTO track_records (id, "playerGuid", "playerName", "trackName", "lapTime", "bikeName", "bikeCategory", "sessionType", "setAt")
          VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
          ON CONFLICT (id) DO UPDATE SET
            "lapTime" = EXCLUDED."lapTime",
            "playerName" = EXCLUDED."playerName",
            "bikeName" = EXCLUDED."bikeName",
            "bikeCategory" = EXCLUDED."bikeCategory",
            "sessionType" = EXCLUDED."sessionType",
            "setAt" = EXCLUDED."setAt"
          WHERE EXCLUDED."lapTime" < track_records."lapTime"
        `, [id, playerGuid, playerName, trackName, lapTime, bikeName || null, bikeCategory || null, sessionType, now]);

        console.log(`[PB-INSTANT] ${playerName} new PB on ${trackName}: ${lapTime}s${improvement > 0 ? ` (-${improvement.toFixed(3)}s)` : ' (first time)'}`);

        // Invalidate track records cache
        this._invalidateCache('trackRecords');

        return {
          isPB: true,
          lapTime,
          previousBest: existingPB,
          improvement,
          playerName,
          trackName
        };
      }

      return {
        isPB: false,
        lapTime,
        currentBest: existingPB
      };
    } finally {
      client.release();
    }
  }

  async getTrackList() {
    const result = await this.pool.query(`
      SELECT "trackName", COUNT(*) as "recordCount", MIN("lapTime") as "bestTime"
      FROM track_records
      GROUP BY "trackName"
      ORDER BY "trackName"
    `);
    return result.rows.map(row => ({
      trackName: row.trackName,
      recordCount: parseInt(row.recordCount),
      bestTime: row.bestTime
    }));
  }

  async getTrackRecords(trackName, limit = 100, category = null) {
    let query = `SELECT * FROM track_records WHERE "trackName" = $1`;
    const params = [trackName];

    if (category) {
      query += ` AND "bikeCategory" = $2`;
      params.push(category);
    }

    query += ` ORDER BY "lapTime" ASC LIMIT $${params.length + 1}`;
    params.push(limit);

    const result = await this.pool.query(query, params);
    return result.rows.map(row => this.rowToTrackRecord(row));
  }

  async getPlayerRecords(guid) {
    const result = await this.pool.query(`
      SELECT * FROM track_records
      WHERE "playerGuid" = $1
      ORDER BY "setAt" DESC
    `, [guid]);
    return result.rows.map(row => this.rowToTrackRecord(row));
  }

  // Get ALL track records (for backwards compatibility)
  async getAllTrackRecords() {
    return this._cachedQuery('trackRecords', async () => {
      const result = await this.pool.query(`
        SELECT * FROM track_records
        ORDER BY "trackName", "lapTime" ASC
      `);
      return result.rows.map(row => this.rowToTrackRecord(row));
    });
  }

  // Get only TOP records per track (much smaller payload for bulk endpoint)
  async getTopTrackRecords(perTrack = 3, category = null) {
    let innerWhere = '';
    const params = [perTrack];

    if (category) {
      innerWhere = `WHERE "bikeCategory" = $2`;
      params.push(category);
    }

    const result = await this.pool.query(`
      SELECT * FROM (
        SELECT *, ROW_NUMBER() OVER (PARTITION BY "trackName" ORDER BY "lapTime" ASC) as rn
        FROM track_records
        ${innerWhere}
      ) ranked
      WHERE rn <= $1
      ORDER BY "trackName", "lapTime" ASC
    `, params);
    return result.rows.map(row => this.rowToTrackRecord(row));
  }

  rowToTrackRecord(row) {
    return {
      id: row.id,
      playerGuid: row.playerGuid,
      playerName: row.playerName,
      trackName: row.trackName,
      lapTime: row.lapTime,
      bikeName: row.bikeName,
      bikeCategory: row.bikeCategory,
      serverName: row.serverName,
      sessionId: row.sessionId,
      sessionType: row.sessionType,
      setAt: row.setAt ? parseInt(row.setAt) : null
    };
  }

  async batchInsertContacts(contacts) {
    if (!contacts || contacts.length === 0) return;

    const client = await this.pool.connect();
    try {
      await client.query('BEGIN');

      for (const c of contacts) {
        const id = `${c.sessionId}_${c.time}_${c.raceNumber1}_${c.raceNumber2}`;
        const isWallContact = c.raceNumber1 === -1 || c.raceNumber2 === -1;

        await client.query(`
          INSERT INTO contacts (id, "sessionId", time, "playerGuid1", "playerName1", "raceNumber1",
            "playerGuid2", "playerName2", "raceNumber2", "isWallContact", "relativeImpactVelocity", "createdAt")
          VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
          ON CONFLICT (id) DO NOTHING
        `, [id, c.sessionId, c.time, c.playerGuid1 || null, c.playerName1 || null, c.raceNumber1,
            c.playerGuid2 || null, c.playerName2 || null, c.raceNumber2, isWallContact,
            c.relativeImpactVelocity || 0, Date.now()]);
      }

      await client.query('COMMIT');
    } catch (err) {
      await client.query('ROLLBACK');
      throw err;
    } finally {
      client.release();
    }
  }

  async batchInsertHoleshots(holeshots) {
    if (!holeshots || holeshots.length === 0) return;

    const client = await this.pool.connect();
    try {
      await client.query('BEGIN');

      for (const h of holeshots) {
        const id = `${h.sessionId}_${h.playerGuid}`;

        await client.query(`
          INSERT INTO holeshots (id, "sessionId", "playerGuid", "playerName", "raceNumber", "holeshotTime", "trackName", "createdAt")
          VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
          ON CONFLICT (id) DO NOTHING
        `, [id, h.sessionId, h.playerGuid, h.playerName, h.raceNumber || 0, h.holeshotTime,
            h.trackName || null, Date.now()]);
      }

      await client.query('COMMIT');
    } catch (err) {
      await client.query('ROLLBACK');
      throw err;
    } finally {
      client.release();
    }
  }

  async getCompleteDataPackage() {
    const [
      players,
      recentSessions,
      trackList,
      totalPlayers,
      topMMR,
      topSR
    ] = await Promise.all([
      this.getAllPlayers(),
      this.getRecentSessions(100),
      this.getTrackList(),
      this.getTotalPlayersCount(),
      this.getTopPlayersByMMR(100),
      this.getTopPlayersBySR(100)
    ]);

    return {
      players,
      recentSessions,
      trackList,
      totalPlayers,
      leaderboards: {
        mmr: topMMR,
        safetyRating: topSR
      }
    };
  }

  async initLeaderTable() {
    console.log('[LEADER] Leader election table ready');
  }

  async tryAcquireLeadership(machineId, staleThresholdMs = 15000) {
    const now = Date.now();
    const client = await this.pool.connect();

    try {
      const result = await client.query(
        'SELECT machine_id, last_heartbeat FROM leader_election WHERE id = $1',
        ['primary']
      );

      if (result.rows.length === 0) {
        try {
          await client.query(
            'INSERT INTO leader_election (id, machine_id, last_heartbeat, acquired_at) VALUES ($1, $2, $3, $4)',
            ['primary', machineId, now, now]
          );
          console.log(`[LEADER] ${machineId} became leader (no previous leader)`);
          return true;
        } catch (insertErr) {
          console.log(`[LEADER] ${machineId} lost race to become leader`);
          return false;
        }
      }

      const currentLeader = result.rows[0];
      const timeSinceHeartbeat = now - parseInt(currentLeader.last_heartbeat);

      if (currentLeader.machine_id === machineId) {
        await client.query(
          'UPDATE leader_election SET last_heartbeat = $1 WHERE id = $2 AND machine_id = $3',
          [now, 'primary', machineId]
        );
        return true;
      }

      if (timeSinceHeartbeat > staleThresholdMs) {
        const updateResult = await client.query(
          'UPDATE leader_election SET machine_id = $1, last_heartbeat = $2, acquired_at = $3 WHERE id = $4 AND last_heartbeat < $5',
          [machineId, now, now, 'primary', now - staleThresholdMs]
        );

        if (updateResult.rowCount > 0) {
          console.log(`[LEADER] ${machineId} took over leadership from stale leader ${currentLeader.machine_id}`);
          return true;
        }
      }

      return false;
    } finally {
      client.release();
    }
  }

  async sendLeaderHeartbeat(machineId) {
    const now = Date.now();
    try {
      const result = await this.pool.query(
        'UPDATE leader_election SET last_heartbeat = $1 WHERE id = $2 AND machine_id = $3',
        [now, 'primary', machineId]
      );
      return result.rowCount > 0;
    } catch (err) {
      console.error('[LEADER] Heartbeat failed:', err.message);
      return false;
    }
  }

  async isLeader(machineId) {
    try {
      const result = await this.pool.query(
        'SELECT machine_id FROM leader_election WHERE id = $1',
        ['primary']
      );
      return result.rows.length > 0 && result.rows[0].machine_id === machineId;
    } catch (err) {
      return false;
    }
  }

  async releaseLeadership(machineId) {
    try {
      await this.pool.query(
        'DELETE FROM leader_election WHERE id = $1 AND machine_id = $2',
        ['primary', machineId]
      );
      console.log(`[LEADER] ${machineId} released leadership`);
    } catch (err) {
      console.error('[LEADER] Failed to release leadership:', err.message);
    }
  }

  // Ban History Methods
  async addBanHistory(entry) {
    const id = `ban_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const now = Date.now();

    await this.pool.query(`
      INSERT INTO ban_history (id, "playerGuid", "playerName", action, reason, duration, "durationType", "isGlobal", "isPermanent", "expiresAt", "performedBy", "sourceManager", "serverName", "evidenceUrl", "createdAt")
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)
    `, [
      id,
      entry.playerGuid,
      entry.playerName,
      entry.action, // 'ban' or 'unban'
      entry.reason || null,
      entry.duration || null,
      entry.durationType || null,
      entry.isGlobal || false,
      entry.isPermanent || false,
      entry.expiresAt || null,
      entry.performedBy || 'System',
      entry.sourceManager || null,
      entry.serverName || null,
      entry.evidenceUrl || null,
      now
    ]);

    return id;
  }

  async getBanHistory(playerGuid) {
    const result = await this.pool.query(`
      SELECT * FROM ban_history
      WHERE UPPER("playerGuid") = UPPER($1)
      ORDER BY "createdAt" DESC
    `, [playerGuid]);

    return result.rows.map(row => ({
      id: row.id,
      playerGuid: row.playerGuid,
      playerName: row.playerName,
      action: row.action,
      reason: row.reason,
      duration: row.duration,
      durationType: row.durationType,
      isGlobal: row.isGlobal,
      isPermanent: row.isPermanent,
      expiresAt: row.expiresAt ? parseInt(row.expiresAt) : null,
      performedBy: row.performedBy,
      sourceManager: row.sourceManager,
      serverName: row.serverName,
      evidenceUrl: row.evidenceUrl || null,
      createdAt: row.createdAt ? parseInt(row.createdAt) : null
    }));
  }

  async getAllBanHistory(limit = 100) {
    const result = await this.pool.query(`
      SELECT * FROM ban_history
      ORDER BY "createdAt" DESC
      LIMIT $1
    `, [limit]);

    return result.rows.map(row => ({
      id: row.id,
      playerGuid: row.playerGuid,
      playerName: row.playerName,
      action: row.action,
      reason: row.reason,
      duration: row.duration,
      durationType: row.durationType,
      isGlobal: row.isGlobal,
      isPermanent: row.isPermanent,
      expiresAt: row.expiresAt ? parseInt(row.expiresAt) : null,
      performedBy: row.performedBy,
      sourceManager: row.sourceManager,
      createdAt: row.createdAt ? parseInt(row.createdAt) : null
    }));
  }

  async deleteBanHistoryEntry(entryId) {
    const result = await this.pool.query(
      `DELETE FROM ban_history WHERE id = $1 RETURNING id`,
      [entryId]
    );
    return result.rows.length > 0;
  }

  // ============ PLAYER WARNINGS ============

  async createWarning(warning) {
    const id = `warning_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
    await this.pool.query(`
      INSERT INTO player_warnings (id, "playerGuid", "playerName", reason, "warnedBy", "warnedByGuid", "reportId", "createdAt")
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
    `, [
      id,
      warning.playerGuid,
      warning.playerName,
      warning.reason,
      warning.warnedBy,
      warning.warnedByGuid || null,
      warning.reportId || null,
      Date.now()
    ]);
    return { id, ...warning };
  }

  async getPlayerWarnings(playerGuid) {
    const result = await this.pool.query(`
      SELECT * FROM player_warnings
      WHERE "playerGuid" = $1
      ORDER BY "createdAt" DESC
    `, [playerGuid]);
    return result.rows;
  }

  async deleteWarning(warningId) {
    const result = await this.pool.query(
      `DELETE FROM player_warnings WHERE id = $1 RETURNING id`,
      [warningId]
    );
    return result.rows.length > 0;
  }

  async acknowledgeWarning(warningId, playerGuid) {
    const result = await this.pool.query(`
      UPDATE player_warnings
      SET acknowledged = TRUE, "acknowledgedAt" = $1
      WHERE id = $2 AND "playerGuid" = $3 AND acknowledged = FALSE
      RETURNING *
    `, [Date.now(), warningId, playerGuid]);
    return result.rows[0] || null;
  }

  async getUnacknowledgedWarnings(playerGuid) {
    const result = await this.pool.query(`
      SELECT * FROM player_warnings
      WHERE "playerGuid" = $1 AND acknowledged = FALSE
      ORDER BY "createdAt" DESC
    `, [playerGuid]);
    return result.rows;
  }

  async getRecentAcknowledgedWarnings(limit = 50) {
    const result = await this.pool.query(`
      SELECT * FROM player_warnings
      WHERE acknowledged = TRUE
      ORDER BY "acknowledgedAt" DESC
      LIMIT $1
    `, [limit]);
    return result.rows;
  }

  // ============ BAN APPEALS ============

  async createBanAppeal(appeal) {
    const id = `appeal_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const now = Date.now();

    const result = await this.pool.query(`
      INSERT INTO ban_appeals (id, "playerGuid", "playerName", "userId", "banReason", "banDate", "banExpiry", "isPermanent", "serverName", "isGlobal", "appealReason", "additionalInfo", "videoUrl", status, "createdAt", "updatedAt")
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)
      RETURNING *
    `, [
      id,
      appeal.playerGuid,
      appeal.playerName,
      appeal.userId,
      appeal.banReason || null,
      appeal.banDate || null,
      appeal.banExpiry || null,
      appeal.isPermanent || false,
      appeal.serverName || null,
      appeal.isGlobal || false,
      appeal.appealReason,
      appeal.additionalInfo || null,
      appeal.videoUrl || null,
      'open',
      now,
      now
    ]);

    return this.rowToAppeal(result.rows[0]);
  }

  async getUserAppeals(userId) {
    const result = await this.pool.query(`
      SELECT * FROM ban_appeals
      WHERE "userId" = $1
      ORDER BY "createdAt" DESC
    `, [userId]);

    return result.rows.map(row => this.rowToAppeal(row));
  }

  async getAppealsByPlayer(playerGuid) {
    const result = await this.pool.query(`
      SELECT * FROM ban_appeals
      WHERE UPPER("playerGuid") = UPPER($1)
      ORDER BY "createdAt" DESC
    `, [playerGuid]);

    return result.rows.map(row => this.rowToAppeal(row));
  }

  async getAllAppeals(status = null) {
    let query = 'SELECT * FROM ban_appeals';
    const params = [];

    if (status) {
      query += ' WHERE status = $1';
      params.push(status);
    }

    query += ' ORDER BY "createdAt" DESC';

    const result = await this.pool.query(query, params);
    return result.rows.map(row => this.rowToAppeal(row));
  }

  async getAppeal(id) {
    const result = await this.pool.query('SELECT * FROM ban_appeals WHERE id = $1', [id]);
    return result.rows.length > 0 ? this.rowToAppeal(result.rows[0]) : null;
  }

  async claimAppeal(id, adminName, adminGuid = null) {
    const now = Date.now();
    const result = await this.pool.query(`
      UPDATE ban_appeals SET status = 'claimed', "claimedBy" = $1, "claimedByGuid" = $2, "claimedAt" = $3, "updatedAt" = $4
      WHERE id = $5 AND status = 'open'
      RETURNING *
    `, [adminName, adminGuid, now, now, id]);
    return result.rows.length > 0 ? this.rowToAppeal(result.rows[0]) : null;
  }

  async transferAppeal(id, newAdminGuid, newAdminName) {
    const now = Date.now();
    const result = await this.pool.query(`
      UPDATE ban_appeals SET "claimedBy" = $1, "claimedByGuid" = $2, "updatedAt" = $3
      WHERE id = $4 AND status = 'claimed'
      RETURNING *
    `, [newAdminName, newAdminGuid, now, id]);
    return result.rows.length > 0 ? this.rowToAppeal(result.rows[0]) : null;
  }

  async resolveAppeal(id, adminName, adminGuid, accepted, resolution, cooldownHours = 24) {
    const now = Date.now();
    const cooldownUntil = accepted ? null : now + (cooldownHours * 60 * 60 * 1000);

    const result = await this.pool.query(`
      UPDATE ban_appeals SET
        status = $1,
        "resolvedBy" = $2,
        "resolvedByGuid" = $3,
        "resolvedAt" = $4,
        resolution = $5,
        "cooldownUntil" = $6,
        "updatedAt" = $7
      WHERE id = $8
      RETURNING *
    `, [accepted ? 'accepted' : 'denied', adminName, adminGuid, now, resolution, cooldownUntil, now, id]);
    return result.rows.length > 0 ? this.rowToAppeal(result.rows[0]) : null;
  }

  async canUserAppeal(userId, playerGuid) {
    // Check if there's a recent denied appeal with cooldown still active
    const result = await this.pool.query(`
      SELECT "cooldownUntil" FROM ban_appeals
      WHERE "userId" = $1 AND UPPER("playerGuid") = UPPER($2) AND status = 'denied' AND "cooldownUntil" > $3
      ORDER BY "createdAt" DESC
      LIMIT 1
    `, [userId, playerGuid, Date.now()]);

    if (result.rows.length > 0) {
      return { canAppeal: false, cooldownUntil: parseInt(result.rows[0].cooldownUntil) };
    }

    // Check if there's already an open or claimed appeal
    const openResult = await this.pool.query(`
      SELECT id FROM ban_appeals
      WHERE "userId" = $1 AND UPPER("playerGuid") = UPPER($2) AND status IN ('open', 'claimed')
      LIMIT 1
    `, [userId, playerGuid]);

    if (openResult.rows.length > 0) {
      return { canAppeal: false, hasOpenAppeal: true };
    }

    return { canAppeal: true };
  }

  // Auto-resolve appeals where the ban has expired
  async autoResolveExpiredAppeals() {
    const now = Date.now();
    const result = await this.pool.query(`
      UPDATE ban_appeals SET
        status = 'accepted',
        "resolvedBy" = 'System',
        "resolvedAt" = $1,
        resolution = 'Ban expired - automatically resolved',
        "updatedAt" = $1
      WHERE status IN ('open', 'claimed')
        AND "isPermanent" = false
        AND "banExpiry" IS NOT NULL
        AND "banExpiry" < $1
      RETURNING *
    `, [now]);

    if (result.rows.length > 0) {
      console.log(`[BAN-APPEAL] Auto-resolved ${result.rows.length} expired ban appeals`);
    }

    return result.rows.map(row => this.rowToAppeal(row));
  }

  rowToAppeal(row) {
    return {
      id: row.id,
      appealIndex: row.appealIndex,
      playerGuid: row.playerGuid,
      playerName: row.playerName,
      userId: row.userId,
      banReason: row.banReason,
      banDate: row.banDate ? parseInt(row.banDate) : null,
      banExpiry: row.banExpiry ? parseInt(row.banExpiry) : null,
      isPermanent: row.isPermanent,
      serverName: row.serverName,
      isGlobal: row.isGlobal,
      appealReason: row.appealReason,
      additionalInfo: row.additionalInfo,
      videoUrl: row.videoUrl,
      status: row.status,
      claimedBy: row.claimedBy,
      claimedByGuid: row.claimedByGuid,
      claimedAt: row.claimedAt ? parseInt(row.claimedAt) : null,
      resolvedBy: row.resolvedBy,
      resolvedByGuid: row.resolvedByGuid,
      resolvedAt: row.resolvedAt ? parseInt(row.resolvedAt) : null,
      resolution: row.resolution,
      cooldownUntil: row.cooldownUntil ? parseInt(row.cooldownUntil) : null,
      createdAt: row.createdAt ? parseInt(row.createdAt) : null,
      updatedAt: row.updatedAt ? parseInt(row.updatedAt) : null
    };
  }

  // ============ PLAYER REPORTS ============

  async createReport(report) {
    const id = `report_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const now = Date.now();

    const result = await this.pool.query(`
      INSERT INTO player_reports (id, "reporterGuid", "reporterName", "reporterUserId", "offenderGuid", "offenderName", "serverName", reason, description, "videoUrl", status, "createdAt", "updatedAt")
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
      RETURNING *
    `, [
      id,
      report.reporterGuid,
      report.reporterName,
      report.reporterUserId,
      report.offenderGuid,
      report.offenderName,
      report.serverName || null,
      report.reason,
      report.description,
      report.videoUrl,
      'open',
      now,
      now
    ]);

    return this.rowToReport(result.rows[0]);
  }

  async getUserReports(userId) {
    const result = await this.pool.query(`
      SELECT * FROM player_reports
      WHERE "reporterUserId" = $1
      ORDER BY "createdAt" DESC
    `, [userId]);

    return result.rows.map(row => this.rowToReport(row));
  }

  async getAllReports(status = null) {
    let query = 'SELECT * FROM player_reports';
    const params = [];

    if (status) {
      query += ' WHERE status = $1';
      params.push(status);
    }

    query += ' ORDER BY "createdAt" DESC';

    const result = await this.pool.query(query, params);
    return result.rows.map(row => this.rowToReport(row));
  }

  async getReport(id) {
    const result = await this.pool.query('SELECT * FROM player_reports WHERE id = $1', [id]);
    return result.rows.length > 0 ? this.rowToReport(result.rows[0]) : null;
  }

  async claimReport(id, adminName, adminGuid = null) {
    const now = Date.now();
    const result = await this.pool.query(`
      UPDATE player_reports SET status = 'claimed', "claimedBy" = $1, "claimedByGuid" = $2, "claimedAt" = $3, "updatedAt" = $4
      WHERE id = $5 AND status = 'open'
      RETURNING *
    `, [adminName, adminGuid, now, now, id]);
    return result.rows.length > 0 ? this.rowToReport(result.rows[0]) : null;
  }

  async transferReport(id, newAdminGuid, newAdminName) {
    const now = Date.now();
    const result = await this.pool.query(`
      UPDATE player_reports SET "claimedBy" = $1, "claimedByGuid" = $2, "updatedAt" = $3
      WHERE id = $4 AND status = 'claimed'
      RETURNING *
    `, [newAdminName, newAdminGuid, now, id]);
    return result.rows.length > 0 ? this.rowToReport(result.rows[0]) : null;
  }

  async resolveReport(id, adminName, adminGuid, actionTaken, resolution) {
    const now = Date.now();
    // Handle pending_ban status - don't mark as resolved yet
    const status = actionTaken === 'pending_ban' ? 'pending_ban'
      : actionTaken === 'no_action' ? 'no_action'
      : 'action_taken';

    // For pending_ban, don't set resolvedAt yet (it's not resolved, just pending review)
    const resolvedAt = actionTaken === 'pending_ban' ? null : now;

    const result = await this.pool.query(`
      UPDATE player_reports SET
        status = $1,
        "resolvedBy" = $2,
        "resolvedByGuid" = $3,
        "resolvedAt" = $4,
        resolution = $5,
        "actionTaken" = $6,
        "updatedAt" = $7
      WHERE id = $8
      RETURNING *
    `, [status, adminName, adminGuid, resolvedAt, resolution, actionTaken, now, id]);
    return result.rows.length > 0 ? this.rowToReport(result.rows[0]) : null;
  }

  async deleteReport(id) {
    // Delete related notifications first
    await this.pool.query(`DELETE FROM notifications WHERE "relatedId" = $1`, [id]);
    const result = await this.pool.query(`DELETE FROM player_reports WHERE id = $1 RETURNING id`, [id]);
    return result.rows.length > 0;
  }

  async deleteAppeal(id) {
    // Delete related notifications first
    await this.pool.query(`DELETE FROM notifications WHERE "relatedId" = $1`, [id]);
    const result = await this.pool.query(`DELETE FROM ban_appeals WHERE id = $1 RETURNING id`, [id]);
    return result.rows.length > 0;
  }

  rowToReport(row) {
    return {
      id: row.id,
      reportIndex: row.reportIndex,
      reporterGuid: row.reporterGuid,
      reporterName: row.reporterName,
      reporterUserId: row.reporterUserId,
      offenderGuid: row.offenderGuid,
      offenderName: row.offenderName,
      serverName: row.serverName,
      reason: row.reason,
      description: row.description,
      videoUrl: row.videoUrl,
      status: row.status,
      claimedBy: row.claimedBy,
      claimedByGuid: row.claimedByGuid,
      claimedAt: row.claimedAt ? parseInt(row.claimedAt) : null,
      resolvedBy: row.resolvedBy,
      resolvedByGuid: row.resolvedByGuid,
      resolvedAt: row.resolvedAt ? parseInt(row.resolvedAt) : null,
      resolution: row.resolution,
      actionTaken: row.actionTaken,
      createdAt: row.createdAt ? parseInt(row.createdAt) : null,
      updatedAt: row.updatedAt ? parseInt(row.updatedAt) : null
    };
  }

  // ============ NOTIFICATIONS ============

  async createNotification(notification) {
    const id = `notif_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const now = Date.now();

    await this.pool.query(`
      INSERT INTO notifications (id, "userId", type, title, message, link, read, "relatedId", "createdAt")
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
    `, [
      id,
      notification.userId,
      notification.type,
      notification.title,
      notification.message,
      notification.link || null,
      false,
      notification.relatedId || null,
      now
    ]);

    return id;
  }

  async getUserNotifications(userId, limit = 50) {
    const result = await this.pool.query(`
      SELECT * FROM notifications
      WHERE "userId" = $1
      ORDER BY "createdAt" DESC
      LIMIT $2
    `, [userId, limit]);

    return result.rows.map(row => ({
      id: row.id,
      userId: row.userId,
      type: row.type,
      title: row.title,
      message: row.message,
      link: row.link,
      read: row.read,
      createdAt: row.createdAt ? parseInt(row.createdAt) : null
    }));
  }

  async getUnreadNotificationCount(userId) {
    const result = await this.pool.query(`
      SELECT COUNT(*) as count FROM notifications
      WHERE "userId" = $1 AND read = FALSE
    `, [userId]);

    return parseInt(result.rows[0].count);
  }

  async getUnreadNotificationCountsByType(userId) {
    const result = await this.pool.query(`
      SELECT
        SUM(CASE WHEN type LIKE '%appeal%' THEN 1 ELSE 0 END) as appeals,
        SUM(CASE WHEN type LIKE '%report%' THEN 1 ELSE 0 END) as reports
      FROM notifications
      WHERE "userId" = $1 AND read = FALSE
    `, [userId]);

    return {
      appeals: parseInt(result.rows[0].appeals) || 0,
      reports: parseInt(result.rows[0].reports) || 0
    };
  }

  async getAdminPendingCounts() {
    const [appealsResult, reportsResult] = await Promise.all([
      this.pool.query(`SELECT COUNT(*) as count FROM ban_appeals WHERE status IN ('open', 'claimed')`),
      this.pool.query(`SELECT COUNT(*) as count FROM player_reports WHERE status IN ('open', 'claimed')`)
    ]);

    return {
      appeals: parseInt(appealsResult.rows[0].count) || 0,
      reports: parseInt(reportsResult.rows[0].count) || 0
    };
  }

  async markNotificationRead(id) {
    await this.pool.query('UPDATE notifications SET read = TRUE WHERE id = $1', [id]);
  }

  async markAllNotificationsRead(userId) {
    await this.pool.query('UPDATE notifications SET read = TRUE WHERE "userId" = $1', [userId]);
  }

  // ============ ANNOUNCEMENTS ============

  async createAnnouncement(announcement) {
    const id = `ann_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const now = Date.now();

    const result = await this.pool.query(`
      INSERT INTO announcements (id, title, message, type, active, "createdBy", "createdByName", "createdAt", "updatedAt", "expiresAt")
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
      RETURNING *
    `, [
      id,
      announcement.title,
      announcement.message,
      announcement.type || 'info',
      true,
      announcement.createdBy,
      announcement.createdByName || null,
      now,
      now,
      announcement.expiresAt || null
    ]);

    return this.rowToAnnouncement(result.rows[0]);
  }

  async getActiveAnnouncements() {
    const now = Date.now();
    const result = await this.pool.query(`
      SELECT * FROM announcements
      WHERE active = TRUE AND ("expiresAt" IS NULL OR "expiresAt" > $1)
      ORDER BY "createdAt" DESC
    `, [now]);

    return result.rows.map(row => this.rowToAnnouncement(row));
  }

  async getAllAnnouncements() {
    const result = await this.pool.query(`
      SELECT * FROM announcements
      ORDER BY "createdAt" DESC
    `);

    return result.rows.map(row => this.rowToAnnouncement(row));
  }

  async getAnnouncementById(id) {
    const result = await this.pool.query('SELECT * FROM announcements WHERE id = $1', [id]);
    return result.rows.length > 0 ? this.rowToAnnouncement(result.rows[0]) : null;
  }

  async updateAnnouncement(id, updates) {
    const now = Date.now();
    const result = await this.pool.query(`
      UPDATE announcements
      SET title = COALESCE($1, title),
          message = COALESCE($2, message),
          type = COALESCE($3, type),
          active = COALESCE($4, active),
          "expiresAt" = $5,
          "updatedAt" = $6
      WHERE id = $7
      RETURNING *
    `, [
      updates.title || null,
      updates.message || null,
      updates.type || null,
      updates.active !== undefined ? updates.active : null,
      updates.expiresAt !== undefined ? updates.expiresAt : null,
      now,
      id
    ]);

    return result.rows.length > 0 ? this.rowToAnnouncement(result.rows[0]) : null;
  }

  async toggleAnnouncementActive(id) {
    const now = Date.now();
    const result = await this.pool.query(`
      UPDATE announcements
      SET active = NOT active, "updatedAt" = $1
      WHERE id = $2
      RETURNING *
    `, [now, id]);

    return result.rows.length > 0 ? this.rowToAnnouncement(result.rows[0]) : null;
  }

  async deleteAnnouncement(id) {
    const result = await this.pool.query('DELETE FROM announcements WHERE id = $1 RETURNING id', [id]);
    return result.rows.length > 0;
  }

  rowToAnnouncement(row) {
    if (!row) return null;
    return {
      id: row.id,
      title: row.title,
      message: row.message,
      type: row.type,
      active: row.active,
      createdBy: row.createdBy,
      createdByName: row.createdByName,
      createdAt: row.createdAt ? parseInt(row.createdAt) : null,
      updatedAt: row.updatedAt ? parseInt(row.updatedAt) : null,
      expiresAt: row.expiresAt ? parseInt(row.expiresAt) : null
    };
  }

  // ============================================
  // Feature Requests
  // ============================================

  async getAllFeatureRequests() {
    const result = await this.pool.query(`
      SELECT * FROM feature_requests
      ORDER BY (COALESCE(array_length(upvotes, 1), 0) - COALESCE(array_length(downvotes, 1), 0)) DESC,
               "createdAt" DESC
    `);

    return result.rows.map(row => this.rowToFeatureRequest(row));
  }

  async createFeatureRequest(data) {
    const id = `fr_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const now = Date.now();

    const result = await this.pool.query(`
      INSERT INTO feature_requests (id, title, description, type, status, "submittedBy", "submittedByName", "submittedByGuid", "createdAt")
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
      RETURNING *
    `, [
      id,
      data.title,
      data.description,
      data.type || 'feature',
      'pending',
      data.submittedBy,
      data.submittedByName,
      data.submittedByGuid || null,
      now
    ]);

    return this.rowToFeatureRequest(result.rows[0]);
  }

  async updateFeatureRequest(id, updates) {
    const now = Date.now();
    const result = await this.pool.query(`
      UPDATE feature_requests
      SET status = COALESCE($1, status),
          "developerComment" = COALESCE($2, "developerComment"),
          "updatedAt" = $3
      WHERE id = $4
      RETURNING *
    `, [
      updates.status || null,
      updates.developerComment !== undefined ? updates.developerComment : null,
      now,
      id
    ]);

    return result.rows.length > 0 ? this.rowToFeatureRequest(result.rows[0]) : null;
  }

  async voteFeatureRequest(id, odg, vote) {
    const now = Date.now();
    let query;

    if (vote === 'up') {
      // Add to upvotes, remove from downvotes
      query = `
        UPDATE feature_requests
        SET upvotes = array_append(array_remove(upvotes, $1), $1),
            downvotes = array_remove(downvotes, $1),
            "updatedAt" = $2
        WHERE id = $3
        RETURNING *
      `;
    } else if (vote === 'down') {
      // Add to downvotes, remove from upvotes
      query = `
        UPDATE feature_requests
        SET downvotes = array_append(array_remove(downvotes, $1), $1),
            upvotes = array_remove(upvotes, $1),
            "updatedAt" = $2
        WHERE id = $3
        RETURNING *
      `;
    } else {
      // Remove from both (vote = 'none')
      query = `
        UPDATE feature_requests
        SET upvotes = array_remove(upvotes, $1),
            downvotes = array_remove(downvotes, $1),
            "updatedAt" = $2
        WHERE id = $3
        RETURNING *
      `;
    }

    const result = await this.pool.query(query, [odg, now, id]);
    return result.rows.length > 0 ? this.rowToFeatureRequest(result.rows[0]) : null;
  }

  async deleteFeatureRequest(id) {
    const result = await this.pool.query('DELETE FROM feature_requests WHERE id = $1 RETURNING id', [id]);
    return result.rows.length > 0;
  }

  rowToFeatureRequest(row) {
    if (!row) return null;
    const upvotes = row.upvotes || [];
    const downvotes = row.downvotes || [];
    return {
      id: row.id,
      requestIndex: row.requestIndex,
      title: row.title,
      description: row.description,
      type: row.type,
      status: row.status,
      submittedBy: row.submittedBy,
      submittedByName: row.submittedByName,
      submittedByGuid: row.submittedByGuid,
      developerComment: row.developerComment,
      upvotes: upvotes,
      downvotes: downvotes,
      voteScore: upvotes.length - downvotes.length,
      createdAt: row.createdAt ? parseInt(row.createdAt) : null,
      updatedAt: row.updatedAt ? parseInt(row.updatedAt) : null
    };
  }

  // ============ SUPPORT TICKETS ============

  async createSupportTicket(ticket) {
    const id = `ticket_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const now = Date.now();

    await this.pool.query(`
      INSERT INTO support_tickets (id, "userId", "userEmail", "reporterGuid", "reporterName", "issueType", subject, description, status, "createdAt", "updatedAt")
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, 'pending', $9, $9)
    `, [
      id,
      ticket.userId,
      ticket.userEmail || null,
      ticket.reporterGuid || null,
      ticket.reporterName || null,
      ticket.issueType,
      ticket.subject,
      ticket.description,
      now
    ]);

    return { id, ...ticket, status: 'pending', createdAt: now, updatedAt: now };
  }

  async getAllSupportTickets(status = null) {
    let query = 'SELECT * FROM support_tickets';
    const params = [];

    if (status) {
      query += ' WHERE status = $1';
      params.push(status);
    }

    query += ' ORDER BY "createdAt" DESC';

    const result = await this.pool.query(query, params);
    return result.rows.map(row => this.rowToSupportTicket(row));
  }

  async getSupportTicket(id) {
    const result = await this.pool.query('SELECT * FROM support_tickets WHERE id = $1', [id]);
    return this.rowToSupportTicket(result.rows[0]);
  }

  async getUserSupportTickets(userId) {
    const result = await this.pool.query(
      'SELECT * FROM support_tickets WHERE "userId" = $1 ORDER BY "createdAt" DESC',
      [userId]
    );
    return result.rows.map(row => this.rowToSupportTicket(row));
  }

  async updateSupportTicket(id, data) {
    const now = Date.now();
    const fields = [];
    const values = [];
    let paramIndex = 1;

    if (data.status !== undefined) {
      fields.push(`status = $${paramIndex++}`);
      values.push(data.status);
    }
    if (data.resolution !== undefined) {
      fields.push(`resolution = $${paramIndex++}`);
      values.push(data.resolution);
    }
    if (data.resolvedBy !== undefined) {
      fields.push(`"resolvedBy" = $${paramIndex++}`);
      values.push(data.resolvedBy);
    }
    if (data.resolvedByGuid !== undefined) {
      fields.push(`"resolvedByGuid" = $${paramIndex++}`);
      values.push(data.resolvedByGuid);
    }
    // Only set resolvedAt when status is actually 'resolved'
    if (data.status === 'resolved') {
      fields.push(`"resolvedAt" = $${paramIndex++}`);
      values.push(now);
    }

    fields.push(`"updatedAt" = $${paramIndex++}`);
    values.push(now);
    values.push(id);

    const result = await this.pool.query(
      `UPDATE support_tickets SET ${fields.join(', ')} WHERE id = $${paramIndex} RETURNING *`,
      values
    );

    return this.rowToSupportTicket(result.rows[0]);
  }

  async deleteSupportTicket(id) {
    const result = await this.pool.query('DELETE FROM support_tickets WHERE id = $1 RETURNING id', [id]);
    return result.rows.length > 0;
  }

  rowToSupportTicket(row) {
    if (!row) return null;
    return {
      id: row.id,
      userId: row.userId,
      userEmail: row.userEmail,
      reporterGuid: row.reporterGuid,
      reporterName: row.reporterName,
      issueType: row.issueType,
      subject: row.subject,
      description: row.description,
      status: row.status,
      resolution: row.resolution,
      resolvedBy: row.resolvedBy,
      resolvedByGuid: row.resolvedByGuid,
      resolvedAt: row.resolvedAt ? parseInt(row.resolvedAt) : null,
      createdAt: row.createdAt ? parseInt(row.createdAt) : null,
      updatedAt: row.updatedAt ? parseInt(row.updatedAt) : null
    };
  }

  // ============ MESSAGE TEMPLATES ============

  async getMessageTemplates() {
    const result = await this.pool.query('SELECT * FROM message_templates WHERE id = $1', ['default']);
    if (result.rows.length === 0) {
      // Return defaults
      return {
        banPrivateMessageEnabled: true,
        banPrivateMessageTemplate: 'You have been banned for {duration}. Reason: {reason}',
        banGlobalMessageEnabled: true,
        banGlobalMessageTemplate: '{name} has been banned for {duration}. Reason: {reason}',
        unbanMessageEnabled: true,
        unbanMessageTemplate: '{name} has been unbanned',
        warningMessageEnabled: true,
        warningMessageTemplate: 'WARNING: {reason}',
        warningGlobalMessageEnabled: true,
        warningGlobalMessageTemplate: '{name} has received a warning: {reason}',
        kickPrivateMessageEnabled: true,
        kickPrivateMessageTemplate: 'You have been kicked. Reason: {reason}',
        kickGlobalMessageEnabled: true,
        kickGlobalMessageTemplate: '{name} has been kicked. Reason: {reason}'
      };
    }
    const row = result.rows[0];
    return {
      banPrivateMessageEnabled: row.banPrivateMessageEnabled,
      banPrivateMessageTemplate: row.banPrivateMessageTemplate,
      banGlobalMessageEnabled: row.banGlobalMessageEnabled,
      banGlobalMessageTemplate: row.banGlobalMessageTemplate,
      unbanMessageEnabled: row.unbanMessageEnabled,
      unbanMessageTemplate: row.unbanMessageTemplate,
      warningMessageEnabled: row.warningMessageEnabled,
      warningMessageTemplate: row.warningMessageTemplate,
      warningGlobalMessageEnabled: row.warningGlobalMessageEnabled,
      warningGlobalMessageTemplate: row.warningGlobalMessageTemplate,
      kickPrivateMessageEnabled: row.kickPrivateMessageEnabled,
      kickPrivateMessageTemplate: row.kickPrivateMessageTemplate,
      kickGlobalMessageEnabled: row.kickGlobalMessageEnabled,
      kickGlobalMessageTemplate: row.kickGlobalMessageTemplate,
      updatedAt: row.updatedAt ? parseInt(row.updatedAt) : null
    };
  }

  async updateMessageTemplates(data) {
    const now = Date.now();
    const result = await this.pool.query(`
      UPDATE message_templates SET
        "banPrivateMessageEnabled" = COALESCE($1, "banPrivateMessageEnabled"),
        "banPrivateMessageTemplate" = COALESCE($2, "banPrivateMessageTemplate"),
        "banGlobalMessageEnabled" = COALESCE($3, "banGlobalMessageEnabled"),
        "banGlobalMessageTemplate" = COALESCE($4, "banGlobalMessageTemplate"),
        "unbanMessageEnabled" = COALESCE($5, "unbanMessageEnabled"),
        "unbanMessageTemplate" = COALESCE($6, "unbanMessageTemplate"),
        "warningMessageEnabled" = COALESCE($7, "warningMessageEnabled"),
        "warningMessageTemplate" = COALESCE($8, "warningMessageTemplate"),
        "warningGlobalMessageEnabled" = COALESCE($9, "warningGlobalMessageEnabled"),
        "warningGlobalMessageTemplate" = COALESCE($10, "warningGlobalMessageTemplate"),
        "kickPrivateMessageEnabled" = COALESCE($11, "kickPrivateMessageEnabled"),
        "kickPrivateMessageTemplate" = COALESCE($12, "kickPrivateMessageTemplate"),
        "kickGlobalMessageEnabled" = COALESCE($13, "kickGlobalMessageEnabled"),
        "kickGlobalMessageTemplate" = COALESCE($14, "kickGlobalMessageTemplate"),
        "updatedAt" = $15
      WHERE id = 'default'
      RETURNING *
    `, [
      data.banPrivateMessageEnabled,
      data.banPrivateMessageTemplate,
      data.banGlobalMessageEnabled,
      data.banGlobalMessageTemplate,
      data.unbanMessageEnabled,
      data.unbanMessageTemplate,
      data.warningMessageEnabled,
      data.warningMessageTemplate,
      data.warningGlobalMessageEnabled,
      data.warningGlobalMessageTemplate,
      data.kickPrivateMessageEnabled,
      data.kickPrivateMessageTemplate,
      data.kickGlobalMessageEnabled,
      data.kickGlobalMessageTemplate,
      now
    ]);
    return this.getMessageTemplates();
  }

  // ============ AUTOMATED MESSAGES ============

  async getAllAutomatedMessages() {
    const result = await this.pool.query(`
      SELECT * FROM automated_messages ORDER BY "createdAt" DESC
    `);
    return result.rows.map(row => ({
      id: row.id,
      message: row.message,
      intervalMinutes: row.intervalMinutes,
      isEnabled: row.isEnabled,
      isGlobal: row.isGlobal,
      serverId: row.serverId,
      serverName: row.serverName,
      lastSent: row.lastSent ? parseInt(row.lastSent) : null,
      createdAt: row.createdAt ? parseInt(row.createdAt) : null,
      updatedAt: row.updatedAt ? parseInt(row.updatedAt) : null
    }));
  }

  async getAutomatedMessagesByServer(serverId) {
    const result = await this.pool.query(`
      SELECT * FROM automated_messages
      WHERE "serverId" = $1 OR "isGlobal" = true
      ORDER BY "createdAt" DESC
    `, [serverId]);
    return result.rows.map(row => ({
      id: row.id,
      message: row.message,
      intervalMinutes: row.intervalMinutes,
      isEnabled: row.isEnabled,
      isGlobal: row.isGlobal,
      serverId: row.serverId,
      serverName: row.serverName,
      lastSent: row.lastSent ? parseInt(row.lastSent) : null,
      createdAt: row.createdAt ? parseInt(row.createdAt) : null,
      updatedAt: row.updatedAt ? parseInt(row.updatedAt) : null
    }));
  }

  async getDueAutomatedMessages() {
    const now = Date.now();
    // Get messages that are enabled and due to be sent
    // A message is due if: lastSent is null OR (now - lastSent) >= intervalMinutes * 60 * 1000
    const result = await this.pool.query(`
      SELECT * FROM automated_messages
      WHERE "isEnabled" = true
      AND ("lastSent" IS NULL OR ($1 - "lastSent") >= ("intervalMinutes" * 60 * 1000))
    `, [now]);
    return result.rows.map(row => ({
      id: row.id,
      message: row.message,
      intervalMinutes: row.intervalMinutes,
      isEnabled: row.isEnabled,
      isGlobal: row.isGlobal,
      serverId: row.serverId,
      serverName: row.serverName,
      lastSent: row.lastSent ? parseInt(row.lastSent) : null,
      createdAt: row.createdAt ? parseInt(row.createdAt) : null,
      updatedAt: row.updatedAt ? parseInt(row.updatedAt) : null
    }));
  }

  async createAutomatedMessage(data) {
    const now = Date.now();
    const id = data.id || `msg_${now}_${Math.random().toString(36).substr(2, 9)}`;

    // Smart spacing: Calculate initial lastSent based on existing messages with same interval
    // This prevents all messages from firing at the same time
    const existingResult = await this.pool.query(`
      SELECT COUNT(*) as count FROM automated_messages
      WHERE "intervalMinutes" = $1 AND "isEnabled" = true
    `, [data.intervalMinutes || 5]);
    const existingCount = parseInt(existingResult.rows[0].count);
    const intervalMs = (data.intervalMinutes || 5) * 60 * 1000;

    // Stagger: spread messages evenly across the interval
    let initialLastSent = null;
    if (existingCount > 0) {
      const offsetMs = (intervalMs / (existingCount + 1)) * existingCount;
      initialLastSent = now - intervalMs + offsetMs;
    }

    await this.pool.query(`
      INSERT INTO automated_messages (id, message, "intervalMinutes", "isEnabled", "isGlobal", "serverId", "serverName", "lastSent", "createdAt")
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
    `, [
      id,
      data.message,
      data.intervalMinutes || 5,
      data.isEnabled !== false,
      data.isGlobal || false,
      data.serverId || null,
      data.serverName || null,
      initialLastSent,
      now
    ]);

    return { id, message: data.message, intervalMinutes: data.intervalMinutes || 5, isEnabled: data.isEnabled !== false, isGlobal: data.isGlobal || false, serverId: data.serverId, serverName: data.serverName, createdAt: now };
  }

  async updateAutomatedMessage(id, data) {
    const now = Date.now();
    const fields = [];
    const values = [];
    let paramIndex = 1;

    if (data.message !== undefined) {
      fields.push(`message = $${paramIndex++}`);
      values.push(data.message);
    }
    if (data.intervalMinutes !== undefined) {
      fields.push(`"intervalMinutes" = $${paramIndex++}`);
      values.push(data.intervalMinutes);
    }
    if (data.isEnabled !== undefined) {
      fields.push(`"isEnabled" = $${paramIndex++}`);
      values.push(data.isEnabled);
    }
    if (data.isGlobal !== undefined) {
      fields.push(`"isGlobal" = $${paramIndex++}`);
      values.push(data.isGlobal);
    }
    if (data.serverId !== undefined) {
      fields.push(`"serverId" = $${paramIndex++}`);
      values.push(data.serverId);
    }
    if (data.serverName !== undefined) {
      fields.push(`"serverName" = $${paramIndex++}`);
      values.push(data.serverName);
    }

    fields.push(`"updatedAt" = $${paramIndex++}`);
    values.push(now);

    values.push(id);

    const result = await this.pool.query(`
      UPDATE automated_messages SET ${fields.join(', ')} WHERE id = $${paramIndex} RETURNING *
    `, values);

    if (result.rows.length === 0) return null;
    const row = result.rows[0];
    return {
      id: row.id,
      message: row.message,
      intervalMinutes: row.intervalMinutes,
      isEnabled: row.isEnabled,
      isGlobal: row.isGlobal,
      serverId: row.serverId,
      serverName: row.serverName,
      lastSent: row.lastSent ? parseInt(row.lastSent) : null,
      createdAt: row.createdAt ? parseInt(row.createdAt) : null,
      updatedAt: row.updatedAt ? parseInt(row.updatedAt) : null
    };
  }

  async updateAutomatedMessageLastSent(id) {
    const now = Date.now();
    await this.pool.query(`
      UPDATE automated_messages SET "lastSent" = $1 WHERE id = $2
    `, [now, id]);
  }

  async deleteAutomatedMessage(id) {
    const result = await this.pool.query(`DELETE FROM automated_messages WHERE id = $1 RETURNING id`, [id]);
    return result.rows.length > 0;
  }

  async close() {
    await this.pool.end();
    console.log('[POSTGRES] Connection pool closed');
  }
}
