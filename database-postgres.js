import pg from 'pg';
const { Pool } = pg;

export class PostgresDatabaseManager {
  constructor(connectionString) {
    this.pool = new Pool({
      connectionString,
      max: 10,
      idleTimeoutMillis: 30000,
      connectionTimeoutMillis: 30000,
      keepAlive: true,
      keepAliveInitialDelayMillis: 10000,
      allowExitOnIdle: false,
    });

    this.pool.on('error', (err) => {
      console.error('[POSTGRES] Unexpected pool error:', err);
    });
  }

  async initializeTables() {
    const client = await this.pool.connect();
    try {
      await client.query(`
        CREATE TABLE IF NOT EXISTS players (
          guid TEXT PRIMARY KEY,
          "displayName" TEXT NOT NULL,
          "displayNameLower" TEXT NOT NULL,
          mmr INTEGER DEFAULT 1000,
          "safetyRating" REAL DEFAULT 0.5,
          "totalRaces" INTEGER DEFAULT 0,
          wins INTEGER DEFAULT 0,
          podiums INTEGER DEFAULT 0,
          holeshots INTEGER DEFAULT 0,
          "raceNumber" INTEGER DEFAULT 0,
          "bikeName" TEXT,
          "currentServer" TEXT,
          "currentTrack" TEXT,
          "lastSeen" BIGINT,
          "firstSeen" BIGINT,
          "autoGenerated" BOOLEAN DEFAULT FALSE,
          "updatedAt" BIGINT,
          "isBanned" BOOLEAN DEFAULT FALSE,
          "banReason" TEXT,
          "banExpiry" BIGINT,
          notes TEXT
        )
      `);

      await client.query(`
        CREATE INDEX IF NOT EXISTS idx_players_mmr ON players(mmr DESC);
        CREATE INDEX IF NOT EXISTS idx_players_sr ON players("safetyRating" DESC);
        CREATE INDEX IF NOT EXISTS idx_players_lastseen ON players("lastSeen" DESC);
        CREATE INDEX IF NOT EXISTS idx_players_namelower ON players("displayNameLower");
      `);

      await client.query(`
        CREATE TABLE IF NOT EXISTS sessions (
          id TEXT PRIMARY KEY,
          "serverId" TEXT NOT NULL,
          "serverName" TEXT NOT NULL,
          "trackName" TEXT NOT NULL,
          "eventName" TEXT DEFAULT '',
          "sessionType" TEXT DEFAULT 'session',
          "currentSessionPhase" TEXT DEFAULT 'warmup',
          "sessionState" TEXT DEFAULT 'WAITING',
          "weatherConditions" TEXT DEFAULT 'Clear',
          "airTemperature" REAL DEFAULT 0,
          "trackLength" REAL DEFAULT 0,
          "startTime" BIGINT,
          "endTime" BIGINT,
          "warmupResults" JSONB DEFAULT '[]'::jsonb,
          "raceResults" JSONB DEFAULT '[]'::jsonb,
          "totalEntries" INTEGER DEFAULT 0,
          "hasFinished" BOOLEAN DEFAULT FALSE,
          "raceFinalized" BOOLEAN DEFAULT FALSE,
          "isActive" BOOLEAN DEFAULT TRUE,
          "createdAt" BIGINT
        )
      `);

      await client.query(`
        CREATE INDEX IF NOT EXISTS idx_sessions_created ON sessions("createdAt" DESC);
        CREATE INDEX IF NOT EXISTS idx_sessions_active ON sessions("isActive") WHERE "isActive" = TRUE;
      `);

      await client.query(`
        CREATE TABLE IF NOT EXISTS player_sessions (
          "playerGuid" TEXT NOT NULL,
          "sessionId" TEXT NOT NULL,
          position INTEGER DEFAULT 0,
          "bestLapTime" REAL DEFAULT 0,
          "totalLaps" INTEGER DEFAULT 0,
          "didFinish" BOOLEAN DEFAULT FALSE,
          "mmrChange" INTEGER DEFAULT 0,
          "srChange" REAL DEFAULT 0,
          PRIMARY KEY ("playerGuid", "sessionId")
        )
      `);

      await client.query(`
        CREATE TABLE IF NOT EXISTS track_records (
          id TEXT PRIMARY KEY,
          "playerGuid" TEXT NOT NULL,
          "playerName" TEXT NOT NULL,
          "trackName" TEXT NOT NULL,
          "lapTime" REAL NOT NULL,
          "bikeName" TEXT,
          "serverName" TEXT DEFAULT '',
          "sessionId" TEXT,
          "sessionType" TEXT DEFAULT 'live',
          "setAt" BIGINT
        )
      `);

      await client.query(`
        CREATE INDEX IF NOT EXISTS idx_track_records_track ON track_records("trackName", "lapTime" ASC);
        CREATE INDEX IF NOT EXISTS idx_track_records_player ON track_records("playerGuid");
      `);

      await client.query(`
        CREATE TABLE IF NOT EXISTS contacts (
          id TEXT PRIMARY KEY,
          "sessionId" TEXT NOT NULL,
          time REAL NOT NULL,
          "playerGuid1" TEXT,
          "playerName1" TEXT,
          "raceNumber1" INTEGER,
          "playerGuid2" TEXT,
          "playerName2" TEXT,
          "raceNumber2" INTEGER,
          "isWallContact" BOOLEAN DEFAULT FALSE,
          "relativeImpactVelocity" REAL,
          "createdAt" BIGINT
        )
      `);

      await client.query(`
        CREATE TABLE IF NOT EXISTS holeshots (
          id TEXT PRIMARY KEY,
          "sessionId" TEXT NOT NULL,
          "playerGuid" TEXT NOT NULL,
          "playerName" TEXT NOT NULL,
          "raceNumber" INTEGER DEFAULT 0,
          "holeshotTime" REAL NOT NULL,
          "trackName" TEXT,
          "createdAt" BIGINT
        )
      `);

      await client.query(`
        CREATE TABLE IF NOT EXISTS leader_election (
          id TEXT PRIMARY KEY DEFAULT 'primary',
          machine_id TEXT NOT NULL,
          last_heartbeat BIGINT NOT NULL,
          acquired_at BIGINT NOT NULL
        )
      `);

      // Ban history table - tracks all bans and unbans
      await client.query(`
        CREATE TABLE IF NOT EXISTS ban_history (
          id TEXT PRIMARY KEY,
          "playerGuid" TEXT NOT NULL,
          "playerName" TEXT NOT NULL,
          action TEXT NOT NULL,
          reason TEXT,
          duration INTEGER,
          "durationType" TEXT,
          "isGlobal" BOOLEAN DEFAULT FALSE,
          "isPermanent" BOOLEAN DEFAULT FALSE,
          "expiresAt" BIGINT,
          "performedBy" TEXT DEFAULT 'System',
          "sourceManager" TEXT,
          "serverName" TEXT,
          "createdAt" BIGINT NOT NULL
        )
      `);

      await client.query(`
        CREATE INDEX IF NOT EXISTS idx_ban_history_player ON ban_history("playerGuid");
        CREATE INDEX IF NOT EXISTS idx_ban_history_created ON ban_history("createdAt" DESC);
      `);

      // Migration: Add serverName column if it doesn't exist
      await client.query(`
        ALTER TABLE ban_history ADD COLUMN IF NOT EXISTS "serverName" TEXT;
      `).catch(() => {}); // Ignore if column exists or alter fails

      // Ban Appeals table
      await client.query(`
        CREATE TABLE IF NOT EXISTS ban_appeals (
          id TEXT PRIMARY KEY,
          "appealIndex" SERIAL,
          "playerGuid" TEXT NOT NULL,
          "playerName" TEXT NOT NULL,
          "userId" TEXT NOT NULL,
          "banReason" TEXT,
          "banDate" BIGINT,
          "banExpiry" BIGINT,
          "isPermanent" BOOLEAN DEFAULT FALSE,
          "serverName" TEXT,
          "isGlobal" BOOLEAN DEFAULT FALSE,
          "appealReason" TEXT NOT NULL,
          "additionalInfo" TEXT,
          "videoUrl" TEXT,
          status TEXT DEFAULT 'open',
          "claimedBy" TEXT,
          "claimedAt" BIGINT,
          "resolvedBy" TEXT,
          "resolvedAt" BIGINT,
          resolution TEXT,
          "cooldownUntil" BIGINT,
          "createdAt" BIGINT NOT NULL,
          "updatedAt" BIGINT
        )
      `);

      // Add videoUrl column if it doesn't exist (for existing databases)
      await client.query(`
        ALTER TABLE ban_appeals ADD COLUMN IF NOT EXISTS "videoUrl" TEXT
      `);

      await client.query(`
        CREATE INDEX IF NOT EXISTS idx_ban_appeals_user ON ban_appeals("userId");
        CREATE INDEX IF NOT EXISTS idx_ban_appeals_player ON ban_appeals("playerGuid");
        CREATE INDEX IF NOT EXISTS idx_ban_appeals_status ON ban_appeals(status);
        CREATE INDEX IF NOT EXISTS idx_ban_appeals_created ON ban_appeals("createdAt" DESC);
      `);

      // Player Reports table
      await client.query(`
        CREATE TABLE IF NOT EXISTS player_reports (
          id TEXT PRIMARY KEY,
          "reportIndex" SERIAL,
          "reporterGuid" TEXT NOT NULL,
          "reporterName" TEXT NOT NULL,
          "reporterUserId" TEXT NOT NULL,
          "offenderGuid" TEXT NOT NULL,
          "offenderName" TEXT NOT NULL,
          "serverName" TEXT,
          reason TEXT NOT NULL,
          description TEXT NOT NULL,
          "videoUrl" TEXT NOT NULL,
          status TEXT DEFAULT 'open',
          "claimedBy" TEXT,
          "claimedAt" BIGINT,
          "resolvedBy" TEXT,
          "resolvedAt" BIGINT,
          resolution TEXT,
          "actionTaken" TEXT,
          "createdAt" BIGINT NOT NULL,
          "updatedAt" BIGINT
        )
      `);

      await client.query(`
        CREATE INDEX IF NOT EXISTS idx_player_reports_user ON player_reports("reporterUserId");
        CREATE INDEX IF NOT EXISTS idx_player_reports_offender ON player_reports("offenderGuid");
        CREATE INDEX IF NOT EXISTS idx_player_reports_status ON player_reports(status);
        CREATE INDEX IF NOT EXISTS idx_player_reports_created ON player_reports("createdAt" DESC);
      `);

      // Notifications table
      await client.query(`
        CREATE TABLE IF NOT EXISTS notifications (
          id TEXT PRIMARY KEY,
          "userId" TEXT NOT NULL,
          type TEXT NOT NULL,
          title TEXT NOT NULL,
          message TEXT NOT NULL,
          link TEXT,
          read BOOLEAN DEFAULT FALSE,
          "createdAt" BIGINT NOT NULL
        )
      `);

      await client.query(`
        CREATE INDEX IF NOT EXISTS idx_notifications_user ON notifications("userId");
        CREATE INDEX IF NOT EXISTS idx_notifications_read ON notifications("userId", read) WHERE read = FALSE;
        CREATE INDEX IF NOT EXISTS idx_notifications_created ON notifications("createdAt" DESC);
      `);

      console.log('[POSTGRES] All tables initialized successfully');
    } finally {
      client.release();
    }
  }

  async upsertPlayer(player) {
    const now = Date.now();
    const displayName = player.displayName || `Player_${player.guid.slice(-8)}`;

    await this.pool.query(`
      INSERT INTO players (guid, "displayName", "displayNameLower", mmr, "safetyRating",
        "totalRaces", wins, podiums, "raceNumber", "bikeName", "currentServer", "currentTrack",
        "lastSeen", "firstSeen", "autoGenerated", "updatedAt")
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)
      ON CONFLICT (guid) DO UPDATE SET
        "displayName" = EXCLUDED."displayName",
        "displayNameLower" = EXCLUDED."displayNameLower",
        "raceNumber" = EXCLUDED."raceNumber",
        "bikeName" = EXCLUDED."bikeName",
        "currentServer" = EXCLUDED."currentServer",
        "currentTrack" = EXCLUDED."currentTrack",
        "lastSeen" = EXCLUDED."lastSeen",
        "updatedAt" = EXCLUDED."updatedAt"
    `, [
      player.guid,
      displayName,
      displayName.toLowerCase(),
      player.mmr || 1000,
      player.safetyRating || 0.5,
      player.totalRaces || 0,
      player.wins || 0,
      player.podiums || 0,
      player.raceNumber || 0,
      player.bikeName || null,
      player.currentServer || null,
      player.currentTrack || null,
      player.lastSeen || now,
      player.firstSeen || now,
      player.autoGenerated || false,
      now
    ]);
  }

  async batchUpsertPlayers(players) {
    if (players.length === 0) return;

    const now = Date.now();
    const client = await this.pool.connect();

    try {
      const guids = [];
      const displayNames = [];
      const displayNamesLower = [];
      const mmrs = [];
      const safetyRatings = [];
      const totalRaces = [];
      const wins = [];
      const podiums = [];
      const raceNumbers = [];
      const bikeNames = [];
      const currentServers = [];
      const currentTracks = [];
      const lastSeens = [];
      const firstSeens = [];
      const autoGenerateds = [];
      const updatedAts = [];

      for (const player of players) {
        const displayName = player.displayName || `Player_${player.guid.slice(-8)}`;
        guids.push(player.guid);
        displayNames.push(displayName);
        displayNamesLower.push(displayName.toLowerCase());
        mmrs.push(player.mmr || 1000);
        safetyRatings.push(player.safetyRating || 0.5);
        totalRaces.push(player.totalRaces || 0);
        wins.push(player.wins || 0);
        podiums.push(player.podiums || 0);
        raceNumbers.push(player.raceNumber || 0);
        bikeNames.push(player.bikeName || null);
        currentServers.push(player.currentServer || null);
        currentTracks.push(player.currentTrack || null);
        lastSeens.push(player.lastSeen || now);
        firstSeens.push(player.firstSeen || now);
        autoGenerateds.push(player.autoGenerated || false);
        updatedAts.push(now);
      }

      await client.query(`
        INSERT INTO players (
          guid, "displayName", "displayNameLower", mmr, "safetyRating",
          "totalRaces", wins, podiums, "raceNumber", "bikeName", "currentServer", "currentTrack",
          "lastSeen", "firstSeen", "autoGenerated", "updatedAt"
        )
        SELECT * FROM UNNEST(
          $1::text[], $2::text[], $3::text[], $4::integer[], $5::real[],
          $6::integer[], $7::integer[], $8::integer[], $9::integer[], $10::text[],
          $11::text[], $12::text[], $13::bigint[], $14::bigint[], $15::boolean[], $16::bigint[]
        )
        ON CONFLICT (guid) DO UPDATE SET
          "displayName" = EXCLUDED."displayName",
          "displayNameLower" = EXCLUDED."displayNameLower",
          "raceNumber" = EXCLUDED."raceNumber",
          "bikeName" = EXCLUDED."bikeName",
          "currentServer" = EXCLUDED."currentServer",
          "currentTrack" = EXCLUDED."currentTrack",
          "lastSeen" = EXCLUDED."lastSeen",
          "updatedAt" = EXCLUDED."updatedAt"
      `, [guids, displayNames, displayNamesLower, mmrs, safetyRatings, totalRaces,
          wins, podiums, raceNumbers, bikeNames, currentServers, currentTracks,
          lastSeens, firstSeens, autoGenerateds, updatedAts]);

    } finally {
      client.release();
    }
  }

  async getPlayer(guid) {
    // Calculate actual race count from session data to ensure accuracy
    // Match any session type containing 'race' (race1, race2, RACE1, RACE2, etc.)
    const result = await this.pool.query(`
      SELECT p.*,
        COALESCE(race_count.count, 0) as "actualTotalRaces",
        COALESCE(win_count.count, 0) as "actualWins",
        COALESCE(podium_count.count, 0) as "actualPodiums"
      FROM players p
      LEFT JOIN (
        SELECT ps."playerGuid", COUNT(*) as count
        FROM player_sessions ps
        INNER JOIN sessions s ON s.id = ps."sessionId"
        WHERE LOWER(s."sessionType") LIKE '%race%'
        GROUP BY ps."playerGuid"
      ) race_count ON race_count."playerGuid" = p.guid
      LEFT JOIN (
        SELECT ps."playerGuid", COUNT(*) as count
        FROM player_sessions ps
        INNER JOIN sessions s ON s.id = ps."sessionId"
        WHERE LOWER(s."sessionType") LIKE '%race%' AND ps.position = 1
        GROUP BY ps."playerGuid"
      ) win_count ON win_count."playerGuid" = p.guid
      LEFT JOIN (
        SELECT ps."playerGuid", COUNT(*) as count
        FROM player_sessions ps
        INNER JOIN sessions s ON s.id = ps."sessionId"
        WHERE LOWER(s."sessionType") LIKE '%race%' AND ps.position <= 3
        GROUP BY ps."playerGuid"
      ) podium_count ON podium_count."playerGuid" = p.guid
      WHERE p.guid = $1
    `, [guid]);

    if (result.rows.length === 0) return null;

    const row = result.rows[0];
    const player = this.rowToPlayer(row);
    // Override with actual counts from session data (use calculated values, not stored)
    const actualRaces = parseInt(row.actualTotalRaces);
    const actualWins = parseInt(row.actualWins);
    const actualPodiums = parseInt(row.actualPodiums);
    player.totalRaces = !isNaN(actualRaces) ? actualRaces : player.totalRaces;
    player.wins = !isNaN(actualWins) ? actualWins : player.wins;
    player.podiums = !isNaN(actualPodiums) ? actualPodiums : player.podiums;
    return player;
  }

  async getAllPlayers() {
    const result = await this.pool.query('SELECT * FROM players ORDER BY "lastSeen" DESC');
    return result.rows.map(row => this.rowToPlayer(row));
  }

  async getTotalPlayersCount() {
    const result = await this.pool.query('SELECT COUNT(*) as count FROM players');
    return parseInt(result.rows[0].count);
  }

  async getBatchPlayers(guids) {
    if (guids.length === 0) return [];
    const placeholders = guids.map((_, i) => `$${i + 1}`).join(',');
    const result = await this.pool.query(
      `SELECT * FROM players WHERE guid IN (${placeholders})`,
      guids
    );
    return result.rows.map(row => this.rowToPlayer(row));
  }

  async getTopPlayersByMMR(limit = 100) {
    const result = await this.pool.query('SELECT * FROM players ORDER BY mmr DESC LIMIT $1', [limit]);
    return result.rows.map(row => this.rowToPlayer(row));
  }

  async getTopPlayersBySR(limit = 100) {
    const result = await this.pool.query('SELECT * FROM players ORDER BY "safetyRating" DESC LIMIT $1', [limit]);
    return result.rows.map(row => this.rowToPlayer(row));
  }

  async updatePlayerMMR(guid, mmrChange, srChange, won = false, podium = false) {
    await this.pool.query(`
      UPDATE players SET
        mmr = GREATEST(0, mmr + $1),
        "safetyRating" = LEAST(1.0, GREATEST(0.0, "safetyRating" + $2)),
        "totalRaces" = "totalRaces" + 1,
        wins = wins + $3,
        podiums = podiums + $4,
        "updatedAt" = $5
      WHERE guid = $6
    `, [mmrChange, srChange, won ? 1 : 0, podium ? 1 : 0, Date.now(), guid]);
  }

  calculateMMRChanges(raceResults) {
    const changes = [];
    const totalPlayers = raceResults.length;

    const holeshotWinner = raceResults
      .filter(r => r.holeshotTime && r.holeshotTime > 0)
      .sort((a, b) => a.holeshotTime - b.holeshotTime)[0];
    const holeshotGuid = holeshotWinner?.playerGuid;

    if (totalPlayers < 3) {
      for (let i = 0; i < raceResults.length; i++) {
        changes.push({
          playerGuid: raceResults[i].playerGuid,
          mmrChange: 0,
          srChange: 0.01,
          won: i === 0,
          podium: i < 3,
          gotHoleshot: raceResults[i].playerGuid === holeshotGuid
        });
      }
      return changes;
    }

    let baseMMR = Math.pow(totalPlayers, 0.70) * 2.4;

    if (totalPlayers <= 5) {
      baseMMR *= 0.6;
    }

    const zeroPoint = Math.ceil(totalPlayers * 0.55);

    for (let i = 0; i < raceResults.length; i++) {
      const player = raceResults[i];
      const position = i + 1;
      let mmrChange = 0;
      let srChange = 0.01;

      if (position < zeroPoint) {
        const positionFactor = Math.pow(
          (zeroPoint - position) / Math.max(1, zeroPoint - 1),
          1.2
        );
        mmrChange = Math.round(baseMMR * positionFactor);

        if (totalPlayers >= 10) {
          if (position === 1) mmrChange += 3;
          if (position === 2) mmrChange += 2;
          if (position === 3) mmrChange += 1;
        }
      } else if (position === zeroPoint) {
        mmrChange = 0;
      } else {
        const lossZone = totalPlayers - zeroPoint;
        const lossFactor = (position - zeroPoint) / lossZone;
        mmrChange = -Math.round((baseMMR * lossFactor) * 0.6);
      }

      changes.push({
        playerGuid: player.playerGuid,
        mmrChange,
        srChange,
        won: position === 1,
        podium: position <= 3,
        gotHoleshot: player.playerGuid === holeshotGuid
      });
    }

    return changes;
  }

  async batchUpdatePlayerMMR(changes) {
    if (changes.length === 0) return;

    const now = Date.now();
    const client = await this.pool.connect();

    try {
      await client.query('BEGIN');

      for (const change of changes) {
        await client.query(`
          UPDATE players SET
            mmr = GREATEST(0, mmr + $1),
            "safetyRating" = LEAST(1.0, GREATEST(0.0, "safetyRating" + $2)),
            "totalRaces" = "totalRaces" + 1,
            wins = wins + $3,
            podiums = podiums + $4,
            holeshots = holeshots + $5,
            "updatedAt" = $6
          WHERE guid = $7
        `, [
          change.mmrChange,
          change.srChange,
          change.won ? 1 : 0,
          change.podium ? 1 : 0,
          change.gotHoleshot ? 1 : 0,
          now,
          change.playerGuid
        ]);
      }

      await client.query('COMMIT');
    } catch (err) {
      await client.query('ROLLBACK');
      throw err;
    } finally {
      client.release();
    }
  }

  async getPlayerSessions(guid, limit = 20) {
    const result = await this.pool.query(`
      SELECT s.*, ps.position, ps."bestLapTime", ps."totalLaps", ps."didFinish", ps."mmrChange", ps."srChange"
      FROM sessions s
      INNER JOIN player_sessions ps ON s.id = ps."sessionId"
      WHERE ps."playerGuid" = $1
      ORDER BY s."createdAt" DESC
      LIMIT $2
    `, [guid, limit]);

    return result.rows.map(row => ({
      ...this.rowToSession(row),
      playerPosition: row.position,
      playerBestLap: row.bestLapTime,
      playerLaps: row.totalLaps,
      playerFinished: row.didFinish,
      mmrChange: row.mmrChange,
      srChange: row.srChange
    }));
  }

  async addPlayerToSession(sessionId, playerGuid, data) {
    await this.pool.query(`
      INSERT INTO player_sessions ("playerGuid", "sessionId", position, "bestLapTime", "totalLaps", "didFinish", "mmrChange", "srChange")
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
      ON CONFLICT ("playerGuid", "sessionId") DO UPDATE SET
        position = EXCLUDED.position,
        "bestLapTime" = EXCLUDED."bestLapTime",
        "totalLaps" = EXCLUDED."totalLaps",
        "didFinish" = EXCLUDED."didFinish",
        "mmrChange" = EXCLUDED."mmrChange",
        "srChange" = EXCLUDED."srChange"
    `, [
      playerGuid,
      sessionId,
      data.position || 0,
      data.bestLapTime || 0,
      data.totalLaps || 0,
      data.didFinish || false,
      data.mmrChange || 0,
      data.srChange || 0
    ]);
  }

  async batchAddPlayersToSession(sessionId, players) {
    if (players.length === 0) return;

    const client = await this.pool.connect();
    try {
      await client.query('BEGIN');

      for (const p of players) {
        await client.query(`
          INSERT INTO player_sessions ("playerGuid", "sessionId", position, "bestLapTime", "totalLaps", "didFinish", "mmrChange", "srChange")
          VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
          ON CONFLICT ("playerGuid", "sessionId") DO UPDATE SET
            position = EXCLUDED.position,
            "bestLapTime" = EXCLUDED."bestLapTime",
            "totalLaps" = EXCLUDED."totalLaps",
            "didFinish" = EXCLUDED."didFinish",
            "mmrChange" = EXCLUDED."mmrChange",
            "srChange" = EXCLUDED."srChange"
        `, [
          p.playerGuid,
          sessionId,
          p.position || 0,
          p.bestLapTime || 0,
          p.totalLaps || 0,
          p.didFinish || false,
          p.mmrChange || 0,
          p.srChange || 0
        ]);
      }

      await client.query('COMMIT');
    } catch (err) {
      await client.query('ROLLBACK');
      throw err;
    } finally {
      client.release();
    }
  }

  rowToPlayer(row) {
    return {
      guid: row.guid,
      displayName: row.displayName,
      mmr: row.mmr,
      safetyRating: row.safetyRating,
      totalRaces: row.totalRaces,
      wins: row.wins,
      podiums: row.podiums,
      holeshots: row.holeshots || 0,
      raceNumber: row.raceNumber,
      bikeName: row.bikeName,
      currentServer: row.currentServer,
      currentTrack: row.currentTrack,
      lastSeen: row.lastSeen ? parseInt(row.lastSeen) : null,
      firstSeen: row.firstSeen ? parseInt(row.firstSeen) : null,
      autoGenerated: row.autoGenerated,
      updatedAt: row.updatedAt ? parseInt(row.updatedAt) : null,
      isBanned: row.isBanned,
      banReason: row.banReason,
      banExpiry: row.banExpiry ? parseInt(row.banExpiry) : null,
      notes: row.notes
    };
  }

  async createSession(session) {
    const id = session.id || `${session.serverId}_${Date.now()}`;
    const now = Date.now();

    await this.pool.query(`
      INSERT INTO sessions (id, "serverId", "serverName", "trackName", "eventName", "sessionType",
        "currentSessionPhase", "sessionState", "weatherConditions", "airTemperature", "trackLength",
        "startTime", "warmupResults", "raceResults", "totalEntries", "hasFinished", "raceFinalized",
        "isActive", "createdAt")
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19)
    `, [
      id,
      session.serverId,
      session.serverName,
      session.trackName,
      session.eventName || '',
      session.sessionType || 'session',
      session.currentSessionPhase || 'warmup',
      session.sessionState || 'WAITING',
      session.weatherConditions || 'Clear',
      session.airTemperature || 0,
      session.trackLength || 0,
      session.startTime || now,
      JSON.stringify(session.warmupResults || []),
      JSON.stringify(session.raceResults || []),
      session.totalEntries || 0,
      session.hasFinished || false,
      session.raceFinalized || false,
      session.isActive !== false,
      now
    ]);

    return id;
  }

  async updateSession(id, updates) {
    const setParts = [];
    const values = [];
    let paramCount = 1;

    if (updates.warmupResults !== undefined) {
      setParts.push(`"warmupResults" = $${paramCount++}`);
      values.push(JSON.stringify(updates.warmupResults));
    }
    if (updates.raceResults !== undefined) {
      setParts.push(`"raceResults" = $${paramCount++}`);
      values.push(JSON.stringify(updates.raceResults));
    }
    if (updates.hasFinished !== undefined) {
      setParts.push(`"hasFinished" = $${paramCount++}`);
      values.push(updates.hasFinished);
    }
    if (updates.raceFinalized !== undefined) {
      setParts.push(`"raceFinalized" = $${paramCount++}`);
      values.push(updates.raceFinalized);
    }
    if (updates.isActive !== undefined) {
      setParts.push(`"isActive" = $${paramCount++}`);
      values.push(updates.isActive);
    }
    if (updates.endTime !== undefined) {
      setParts.push(`"endTime" = $${paramCount++}`);
      values.push(updates.endTime);
    }
    if (updates.currentSessionPhase !== undefined) {
      setParts.push(`"currentSessionPhase" = $${paramCount++}`);
      values.push(updates.currentSessionPhase);
    }
    if (updates.sessionState !== undefined) {
      setParts.push(`"sessionState" = $${paramCount++}`);
      values.push(updates.sessionState);
    }
    if (updates.totalEntries !== undefined) {
      setParts.push(`"totalEntries" = $${paramCount++}`);
      values.push(updates.totalEntries);
    }
    if (updates.trackName !== undefined) {
      setParts.push(`"trackName" = $${paramCount++}`);
      values.push(updates.trackName);
    }

    if (setParts.length === 0) return;

    values.push(id);
    await this.pool.query(
      `UPDATE sessions SET ${setParts.join(', ')} WHERE id = $${paramCount}`,
      values
    );
  }

  async batchUpdateSessions(sessionUpdates) {
    if (sessionUpdates.length === 0) return;

    const client = await this.pool.connect();
    try {
      await client.query('BEGIN');

      for (const update of sessionUpdates) {
        await client.query(`
          UPDATE sessions SET
            "warmupResults" = $1,
            "totalEntries" = $2
          WHERE id = $3
        `, [
          JSON.stringify(update.updates.warmupResults),
          update.updates.totalEntries,
          update.sessionId
        ]);
      }

      await client.query('COMMIT');
    } catch (err) {
      await client.query('ROLLBACK');
      throw err;
    } finally {
      client.release();
    }
  }

  async getRecentSessions(limit = 50) {
    const result = await this.pool.query(`
      SELECT * FROM sessions
      WHERE ("raceFinalized" = TRUE AND "totalEntries" > 0) OR "isActive" = TRUE
      ORDER BY "startTime" DESC
      LIMIT $1
    `, [limit]);
    return result.rows.map(row => this.rowToSession(row));
  }

  async getSession(sessionId) {
    const result = await this.pool.query('SELECT * FROM sessions WHERE id = $1', [sessionId]);
    return result.rows.length > 0 ? this.rowToSession(result.rows[0]) : null;
  }

  async getActiveSessions() {
    const result = await this.pool.query(`
      SELECT * FROM sessions WHERE "isActive" = TRUE AND "hasFinished" = FALSE
    `);
    return result.rows.map(row => this.rowToSession(row));
  }

  async getTotalFinalizedSessionsCount() {
    const result = await this.pool.query(`
      SELECT COUNT(*) as count FROM sessions
      WHERE "raceFinalized" = TRUE AND "totalEntries" > 0
    `);
    return parseInt(result.rows[0].count) || 0;
  }

  rowToSession(row) {
    return {
      id: row.id,
      serverId: row.serverId,
      serverName: row.serverName,
      trackName: row.trackName,
      eventName: row.eventName,
      sessionType: row.sessionType,
      currentSessionPhase: row.currentSessionPhase,
      sessionState: row.sessionState,
      weatherConditions: row.weatherConditions,
      airTemperature: row.airTemperature,
      trackLength: row.trackLength,
      startTime: row.startTime ? parseInt(row.startTime) : null,
      endTime: row.endTime ? parseInt(row.endTime) : null,
      warmupResults: row.warmupResults || [],
      raceResults: row.raceResults || [],
      totalEntries: row.totalEntries,
      hasFinished: row.hasFinished,
      raceFinalized: row.raceFinalized,
      isActive: row.isActive,
      createdAt: row.createdAt ? parseInt(row.createdAt) : null
    };
  }

  async checkSinglePlayerPB(record) {
    const { playerGuid, playerName, trackName, lapTime, sessionType, bikeName } = record;
    const id = `${playerGuid}_${trackName}`;
    const now = Date.now();

    const client = await this.pool.connect();
    try {
      const existingResult = await client.query(
        'SELECT "lapTime" FROM track_records WHERE id = $1',
        [id]
      );

      const existingPB = existingResult.rows.length > 0 ? existingResult.rows[0].lapTime : null;
      const isNewPB = !existingPB || lapTime < existingPB;

      if (isNewPB) {
        const improvement = existingPB ? existingPB - lapTime : 0;

        await client.query(`
          INSERT INTO track_records (id, "playerGuid", "playerName", "trackName", "lapTime", "bikeName", "sessionType", "setAt")
          VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
          ON CONFLICT (id) DO UPDATE SET
            "lapTime" = EXCLUDED."lapTime",
            "playerName" = EXCLUDED."playerName",
            "bikeName" = EXCLUDED."bikeName",
            "sessionType" = EXCLUDED."sessionType",
            "setAt" = EXCLUDED."setAt"
          WHERE EXCLUDED."lapTime" < track_records."lapTime"
        `, [id, playerGuid, playerName, trackName, lapTime, bikeName || null, sessionType, now]);

        console.log(`[PB-INSTANT] ${playerName} new PB on ${trackName}: ${lapTime}s${improvement > 0 ? ` (-${improvement.toFixed(3)}s)` : ' (first time)'}`);

        return {
          isPB: true,
          lapTime,
          previousBest: existingPB,
          improvement,
          playerName,
          trackName
        };
      }

      return {
        isPB: false,
        lapTime,
        currentBest: existingPB
      };
    } finally {
      client.release();
    }
  }

  async getTrackList() {
    const result = await this.pool.query(`
      SELECT "trackName", COUNT(*) as "recordCount", MIN("lapTime") as "bestTime"
      FROM track_records
      GROUP BY "trackName"
      ORDER BY "trackName"
    `);
    return result.rows.map(row => ({
      trackName: row.trackName,
      recordCount: parseInt(row.recordCount),
      bestTime: row.bestTime
    }));
  }

  async getTrackRecords(trackName, limit = 100) {
    const result = await this.pool.query(`
      SELECT * FROM track_records
      WHERE "trackName" = $1
      ORDER BY "lapTime" ASC
      LIMIT $2
    `, [trackName, limit]);
    return result.rows.map(row => this.rowToTrackRecord(row));
  }

  async getPlayerRecords(guid) {
    const result = await this.pool.query(`
      SELECT * FROM track_records
      WHERE "playerGuid" = $1
      ORDER BY "setAt" DESC
    `, [guid]);
    return result.rows.map(row => this.rowToTrackRecord(row));
  }

  async getAllTrackRecords() {
    const result = await this.pool.query(`
      SELECT * FROM track_records
      ORDER BY "trackName", "lapTime" ASC
    `);
    return result.rows.map(row => this.rowToTrackRecord(row));
  }

  rowToTrackRecord(row) {
    return {
      id: row.id,
      playerGuid: row.playerGuid,
      playerName: row.playerName,
      trackName: row.trackName,
      lapTime: row.lapTime,
      bikeName: row.bikeName,
      serverName: row.serverName,
      sessionId: row.sessionId,
      sessionType: row.sessionType,
      setAt: row.setAt ? parseInt(row.setAt) : null
    };
  }

  async batchInsertContacts(contacts) {
    if (!contacts || contacts.length === 0) return;

    const client = await this.pool.connect();
    try {
      await client.query('BEGIN');

      for (const c of contacts) {
        const id = `${c.sessionId}_${c.time}_${c.raceNumber1}_${c.raceNumber2}`;
        const isWallContact = c.raceNumber1 === -1 || c.raceNumber2 === -1;

        await client.query(`
          INSERT INTO contacts (id, "sessionId", time, "playerGuid1", "playerName1", "raceNumber1",
            "playerGuid2", "playerName2", "raceNumber2", "isWallContact", "relativeImpactVelocity", "createdAt")
          VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
          ON CONFLICT (id) DO NOTHING
        `, [id, c.sessionId, c.time, c.playerGuid1 || null, c.playerName1 || null, c.raceNumber1,
            c.playerGuid2 || null, c.playerName2 || null, c.raceNumber2, isWallContact,
            c.relativeImpactVelocity || 0, Date.now()]);
      }

      await client.query('COMMIT');
    } catch (err) {
      await client.query('ROLLBACK');
      throw err;
    } finally {
      client.release();
    }
  }

  async batchInsertHoleshots(holeshots) {
    if (!holeshots || holeshots.length === 0) return;

    const client = await this.pool.connect();
    try {
      await client.query('BEGIN');

      for (const h of holeshots) {
        const id = `${h.sessionId}_${h.playerGuid}`;

        await client.query(`
          INSERT INTO holeshots (id, "sessionId", "playerGuid", "playerName", "raceNumber", "holeshotTime", "trackName", "createdAt")
          VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
          ON CONFLICT (id) DO NOTHING
        `, [id, h.sessionId, h.playerGuid, h.playerName, h.raceNumber || 0, h.holeshotTime,
            h.trackName || null, Date.now()]);
      }

      await client.query('COMMIT');
    } catch (err) {
      await client.query('ROLLBACK');
      throw err;
    } finally {
      client.release();
    }
  }

  async getCompleteDataPackage() {
    const [
      players,
      recentSessions,
      trackList,
      totalPlayers,
      topMMR,
      topSR
    ] = await Promise.all([
      this.getAllPlayers(),
      this.getRecentSessions(100),
      this.getTrackList(),
      this.getTotalPlayersCount(),
      this.getTopPlayersByMMR(100),
      this.getTopPlayersBySR(100)
    ]);

    return {
      players,
      recentSessions,
      trackList,
      totalPlayers,
      leaderboards: {
        mmr: topMMR,
        safetyRating: topSR
      }
    };
  }

  async initLeaderTable() {
    console.log('[LEADER] Leader election table ready');
  }

  async tryAcquireLeadership(machineId, staleThresholdMs = 15000) {
    const now = Date.now();
    const client = await this.pool.connect();

    try {
      const result = await client.query(
        'SELECT machine_id, last_heartbeat FROM leader_election WHERE id = $1',
        ['primary']
      );

      if (result.rows.length === 0) {
        try {
          await client.query(
            'INSERT INTO leader_election (id, machine_id, last_heartbeat, acquired_at) VALUES ($1, $2, $3, $4)',
            ['primary', machineId, now, now]
          );
          console.log(`[LEADER] ${machineId} became leader (no previous leader)`);
          return true;
        } catch (insertErr) {
          console.log(`[LEADER] ${machineId} lost race to become leader`);
          return false;
        }
      }

      const currentLeader = result.rows[0];
      const timeSinceHeartbeat = now - parseInt(currentLeader.last_heartbeat);

      if (currentLeader.machine_id === machineId) {
        await client.query(
          'UPDATE leader_election SET last_heartbeat = $1 WHERE id = $2 AND machine_id = $3',
          [now, 'primary', machineId]
        );
        return true;
      }

      if (timeSinceHeartbeat > staleThresholdMs) {
        const updateResult = await client.query(
          'UPDATE leader_election SET machine_id = $1, last_heartbeat = $2, acquired_at = $3 WHERE id = $4 AND last_heartbeat < $5',
          [machineId, now, now, 'primary', now - staleThresholdMs]
        );

        if (updateResult.rowCount > 0) {
          console.log(`[LEADER] ${machineId} took over leadership from stale leader ${currentLeader.machine_id}`);
          return true;
        }
      }

      return false;
    } finally {
      client.release();
    }
  }

  async sendLeaderHeartbeat(machineId) {
    const now = Date.now();
    try {
      const result = await this.pool.query(
        'UPDATE leader_election SET last_heartbeat = $1 WHERE id = $2 AND machine_id = $3',
        [now, 'primary', machineId]
      );
      return result.rowCount > 0;
    } catch (err) {
      console.error('[LEADER] Heartbeat failed:', err.message);
      return false;
    }
  }

  async isLeader(machineId) {
    try {
      const result = await this.pool.query(
        'SELECT machine_id FROM leader_election WHERE id = $1',
        ['primary']
      );
      return result.rows.length > 0 && result.rows[0].machine_id === machineId;
    } catch (err) {
      return false;
    }
  }

  async releaseLeadership(machineId) {
    try {
      await this.pool.query(
        'DELETE FROM leader_election WHERE id = $1 AND machine_id = $2',
        ['primary', machineId]
      );
      console.log(`[LEADER] ${machineId} released leadership`);
    } catch (err) {
      console.error('[LEADER] Failed to release leadership:', err.message);
    }
  }

  // Ban History Methods
  async addBanHistory(entry) {
    const id = `ban_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const now = Date.now();

    await this.pool.query(`
      INSERT INTO ban_history (id, "playerGuid", "playerName", action, reason, duration, "durationType", "isGlobal", "isPermanent", "expiresAt", "performedBy", "sourceManager", "serverName", "createdAt")
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)
    `, [
      id,
      entry.playerGuid,
      entry.playerName,
      entry.action, // 'ban' or 'unban'
      entry.reason || null,
      entry.duration || null,
      entry.durationType || null,
      entry.isGlobal || false,
      entry.isPermanent || false,
      entry.expiresAt || null,
      entry.performedBy || 'System',
      entry.sourceManager || null,
      entry.serverName || null,
      now
    ]);

    return id;
  }

  async getBanHistory(playerGuid) {
    const result = await this.pool.query(`
      SELECT * FROM ban_history
      WHERE UPPER("playerGuid") = UPPER($1)
      ORDER BY "createdAt" DESC
    `, [playerGuid]);

    return result.rows.map(row => ({
      id: row.id,
      playerGuid: row.playerGuid,
      playerName: row.playerName,
      action: row.action,
      reason: row.reason,
      duration: row.duration,
      durationType: row.durationType,
      isGlobal: row.isGlobal,
      isPermanent: row.isPermanent,
      expiresAt: row.expiresAt ? parseInt(row.expiresAt) : null,
      performedBy: row.performedBy,
      sourceManager: row.sourceManager,
      serverName: row.serverName,
      createdAt: row.createdAt ? parseInt(row.createdAt) : null
    }));
  }

  async getAllBanHistory(limit = 100) {
    const result = await this.pool.query(`
      SELECT * FROM ban_history
      ORDER BY "createdAt" DESC
      LIMIT $1
    `, [limit]);

    return result.rows.map(row => ({
      id: row.id,
      playerGuid: row.playerGuid,
      playerName: row.playerName,
      action: row.action,
      reason: row.reason,
      duration: row.duration,
      durationType: row.durationType,
      isGlobal: row.isGlobal,
      isPermanent: row.isPermanent,
      expiresAt: row.expiresAt ? parseInt(row.expiresAt) : null,
      performedBy: row.performedBy,
      sourceManager: row.sourceManager,
      createdAt: row.createdAt ? parseInt(row.createdAt) : null
    }));
  }

  // ============ BAN APPEALS ============

  async createBanAppeal(appeal) {
    const id = `appeal_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const now = Date.now();

    await this.pool.query(`
      INSERT INTO ban_appeals (id, "playerGuid", "playerName", "userId", "banReason", "banDate", "banExpiry", "isPermanent", "serverName", "isGlobal", "appealReason", "additionalInfo", "videoUrl", status, "createdAt", "updatedAt")
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)
    `, [
      id,
      appeal.playerGuid,
      appeal.playerName,
      appeal.userId,
      appeal.banReason || null,
      appeal.banDate || null,
      appeal.banExpiry || null,
      appeal.isPermanent || false,
      appeal.serverName || null,
      appeal.isGlobal || false,
      appeal.appealReason,
      appeal.additionalInfo || null,
      appeal.videoUrl || null,
      'open',
      now,
      now
    ]);

    return id;
  }

  async getUserAppeals(userId) {
    const result = await this.pool.query(`
      SELECT * FROM ban_appeals
      WHERE "userId" = $1
      ORDER BY "createdAt" DESC
    `, [userId]);

    return result.rows.map(row => this.rowToAppeal(row));
  }

  async getAppealsByPlayer(playerGuid) {
    const result = await this.pool.query(`
      SELECT * FROM ban_appeals
      WHERE UPPER("playerGuid") = UPPER($1)
      ORDER BY "createdAt" DESC
    `, [playerGuid]);

    return result.rows.map(row => this.rowToAppeal(row));
  }

  async getAllAppeals(status = null) {
    let query = 'SELECT * FROM ban_appeals';
    const params = [];

    if (status) {
      query += ' WHERE status = $1';
      params.push(status);
    }

    query += ' ORDER BY "createdAt" DESC';

    const result = await this.pool.query(query, params);
    return result.rows.map(row => this.rowToAppeal(row));
  }

  async getAppeal(id) {
    const result = await this.pool.query('SELECT * FROM ban_appeals WHERE id = $1', [id]);
    return result.rows.length > 0 ? this.rowToAppeal(result.rows[0]) : null;
  }

  async claimAppeal(id, adminName) {
    const now = Date.now();
    const result = await this.pool.query(`
      UPDATE ban_appeals SET status = 'claimed', "claimedBy" = $1, "claimedAt" = $2, "updatedAt" = $3
      WHERE id = $4 AND status = 'open'
      RETURNING *
    `, [adminName, now, now, id]);
    return result.rows.length > 0 ? this.rowToAppeal(result.rows[0]) : null;
  }

  async resolveAppeal(id, adminName, accepted, resolution, cooldownHours = 24) {
    const now = Date.now();
    const cooldownUntil = accepted ? null : now + (cooldownHours * 60 * 60 * 1000);

    const result = await this.pool.query(`
      UPDATE ban_appeals SET
        status = $1,
        "resolvedBy" = $2,
        "resolvedAt" = $3,
        resolution = $4,
        "cooldownUntil" = $5,
        "updatedAt" = $6
      WHERE id = $7
      RETURNING *
    `, [accepted ? 'accepted' : 'denied', adminName, now, resolution, cooldownUntil, now, id]);
    return result.rows.length > 0 ? this.rowToAppeal(result.rows[0]) : null;
  }

  async canUserAppeal(userId, playerGuid) {
    // Check if there's a recent denied appeal with cooldown still active
    const result = await this.pool.query(`
      SELECT "cooldownUntil" FROM ban_appeals
      WHERE "userId" = $1 AND UPPER("playerGuid") = UPPER($2) AND status = 'denied' AND "cooldownUntil" > $3
      ORDER BY "createdAt" DESC
      LIMIT 1
    `, [userId, playerGuid, Date.now()]);

    if (result.rows.length > 0) {
      return { canAppeal: false, cooldownUntil: parseInt(result.rows[0].cooldownUntil) };
    }

    // Check if there's already an open or claimed appeal
    const openResult = await this.pool.query(`
      SELECT id FROM ban_appeals
      WHERE "userId" = $1 AND UPPER("playerGuid") = UPPER($2) AND status IN ('open', 'claimed')
      LIMIT 1
    `, [userId, playerGuid]);

    if (openResult.rows.length > 0) {
      return { canAppeal: false, hasOpenAppeal: true };
    }

    return { canAppeal: true };
  }

  rowToAppeal(row) {
    return {
      id: row.id,
      appealIndex: row.appealIndex,
      playerGuid: row.playerGuid,
      playerName: row.playerName,
      userId: row.userId,
      banReason: row.banReason,
      banDate: row.banDate ? parseInt(row.banDate) : null,
      banExpiry: row.banExpiry ? parseInt(row.banExpiry) : null,
      isPermanent: row.isPermanent,
      serverName: row.serverName,
      isGlobal: row.isGlobal,
      appealReason: row.appealReason,
      additionalInfo: row.additionalInfo,
      videoUrl: row.videoUrl,
      status: row.status,
      claimedBy: row.claimedBy,
      claimedAt: row.claimedAt ? parseInt(row.claimedAt) : null,
      resolvedBy: row.resolvedBy,
      resolvedAt: row.resolvedAt ? parseInt(row.resolvedAt) : null,
      resolution: row.resolution,
      cooldownUntil: row.cooldownUntil ? parseInt(row.cooldownUntil) : null,
      createdAt: row.createdAt ? parseInt(row.createdAt) : null,
      updatedAt: row.updatedAt ? parseInt(row.updatedAt) : null
    };
  }

  // ============ PLAYER REPORTS ============

  async createReport(report) {
    const id = `report_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const now = Date.now();

    await this.pool.query(`
      INSERT INTO player_reports (id, "reporterGuid", "reporterName", "reporterUserId", "offenderGuid", "offenderName", "serverName", reason, description, "videoUrl", status, "createdAt", "updatedAt")
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
    `, [
      id,
      report.reporterGuid,
      report.reporterName,
      report.reporterUserId,
      report.offenderGuid,
      report.offenderName,
      report.serverName || null,
      report.reason,
      report.description,
      report.videoUrl,
      'open',
      now,
      now
    ]);

    return id;
  }

  async getUserReports(userId) {
    const result = await this.pool.query(`
      SELECT * FROM player_reports
      WHERE "reporterUserId" = $1
      ORDER BY "createdAt" DESC
    `, [userId]);

    return result.rows.map(row => this.rowToReport(row));
  }

  async getAllReports(status = null) {
    let query = 'SELECT * FROM player_reports';
    const params = [];

    if (status) {
      query += ' WHERE status = $1';
      params.push(status);
    }

    query += ' ORDER BY "createdAt" DESC';

    const result = await this.pool.query(query, params);
    return result.rows.map(row => this.rowToReport(row));
  }

  async getReport(id) {
    const result = await this.pool.query('SELECT * FROM player_reports WHERE id = $1', [id]);
    return result.rows.length > 0 ? this.rowToReport(result.rows[0]) : null;
  }

  async claimReport(id, adminName) {
    const now = Date.now();
    const result = await this.pool.query(`
      UPDATE player_reports SET status = 'claimed', "claimedBy" = $1, "claimedAt" = $2, "updatedAt" = $3
      WHERE id = $4 AND status = 'open'
      RETURNING *
    `, [adminName, now, now, id]);
    return result.rows.length > 0 ? this.rowToReport(result.rows[0]) : null;
  }

  async resolveReport(id, adminName, actionTaken, resolution) {
    const now = Date.now();
    const status = actionTaken === 'no_action' ? 'no_action' : 'action_taken';

    const result = await this.pool.query(`
      UPDATE player_reports SET
        status = $1,
        "resolvedBy" = $2,
        "resolvedAt" = $3,
        resolution = $4,
        "actionTaken" = $5,
        "updatedAt" = $6
      WHERE id = $7
      RETURNING *
    `, [status, adminName, now, resolution, actionTaken, now, id]);
    return result.rows.length > 0 ? this.rowToReport(result.rows[0]) : null;
  }

  async deleteReport(id) {
    const result = await this.pool.query(`DELETE FROM player_reports WHERE id = $1 RETURNING id`, [id]);
    return result.rows.length > 0;
  }

  async deleteAppeal(id) {
    const result = await this.pool.query(`DELETE FROM ban_appeals WHERE id = $1 RETURNING id`, [id]);
    return result.rows.length > 0;
  }

  rowToReport(row) {
    return {
      id: row.id,
      reportIndex: row.reportIndex,
      reporterGuid: row.reporterGuid,
      reporterName: row.reporterName,
      reporterUserId: row.reporterUserId,
      offenderGuid: row.offenderGuid,
      offenderName: row.offenderName,
      serverName: row.serverName,
      reason: row.reason,
      description: row.description,
      videoUrl: row.videoUrl,
      status: row.status,
      claimedBy: row.claimedBy,
      claimedAt: row.claimedAt ? parseInt(row.claimedAt) : null,
      resolvedBy: row.resolvedBy,
      resolvedAt: row.resolvedAt ? parseInt(row.resolvedAt) : null,
      resolution: row.resolution,
      actionTaken: row.actionTaken,
      createdAt: row.createdAt ? parseInt(row.createdAt) : null,
      updatedAt: row.updatedAt ? parseInt(row.updatedAt) : null
    };
  }

  // ============ NOTIFICATIONS ============

  async createNotification(notification) {
    const id = `notif_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const now = Date.now();

    await this.pool.query(`
      INSERT INTO notifications (id, "userId", type, title, message, link, read, "createdAt")
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
    `, [
      id,
      notification.userId,
      notification.type,
      notification.title,
      notification.message,
      notification.link || null,
      false,
      now
    ]);

    return id;
  }

  async getUserNotifications(userId, limit = 50) {
    const result = await this.pool.query(`
      SELECT * FROM notifications
      WHERE "userId" = $1
      ORDER BY "createdAt" DESC
      LIMIT $2
    `, [userId, limit]);

    return result.rows.map(row => ({
      id: row.id,
      userId: row.userId,
      type: row.type,
      title: row.title,
      message: row.message,
      link: row.link,
      read: row.read,
      createdAt: row.createdAt ? parseInt(row.createdAt) : null
    }));
  }

  async getUnreadNotificationCount(userId) {
    const result = await this.pool.query(`
      SELECT COUNT(*) as count FROM notifications
      WHERE "userId" = $1 AND read = FALSE
    `, [userId]);

    return parseInt(result.rows[0].count);
  }

  async markNotificationRead(id) {
    await this.pool.query('UPDATE notifications SET read = TRUE WHERE id = $1', [id]);
  }

  async markAllNotificationsRead(userId) {
    await this.pool.query('UPDATE notifications SET read = TRUE WHERE "userId" = $1', [userId]);
  }

  async close() {
    await this.pool.end();
    console.log('[POSTGRES] Connection pool closed');
  }
}
