import { setMaxListeners } from 'events';

export class StateManager {
  constructor(db, env) {
    this.db = db;
    this.env = env;
    this.previousServerStates = new Map();
    this.serverSessions = new Map();
    this.serverSessionPhases = new Map();
    this.mmrSentSessions = new Set();
    this.serverToApiMap = new Map();
    this.cachedPlayerStates = new Map();
    this.insertedHoleshots = new Map();
    this.insertedContacts = new Map();
    this.cachedWarmupStates = new Map();
    this.serverTracks = new Map();
    this.LASTSEEN_UPDATE_INTERVAL = 60000;
    this.cachedServerData = null;
    this.lastServerDataFetch = 0;
    this.alarmCounter = 0;
    // Track sessions being processed to prevent race conditions
    this.processingRaceSessions = new Set();
    // Store last warmup results for sessions to ensure they're saved before transition
    this.lastWarmupResults = new Map();
    // Network optimization: cache detailed server data between full fetches
    this.cachedDetailedServers = new Map(); // serverId -> detailed data
    this.detailedFetchCounter = 0;
    this.DETAILED_FETCH_INTERVAL = 3; // Fetch detailed data every 3rd cycle (45s at 15s interval)
  }

  async recoverStateFromDatabase() {
    try {
      const sessions = await this.db.getActiveSessions();
      if (!sessions.length) { console.log('[RECOVERY] No active sessions'); return; }
      for (const s of sessions) {
        this.serverSessions.set(s.serverId, s.id);
        if (s.currentSessionPhase) this.serverSessionPhases.set(s.serverId, s.currentSessionPhase);
        if (s.sessionState) this.previousServerStates.set(s.serverId, s.sessionState);
        if (s.raceResults?.length) this.mmrSentSessions.add(s.id);
      }
      console.log(`[RECOVERY] ${sessions.length} sessions, ${this.mmrSentSessions.size} with MMR`);
    } catch (err) { console.error('[RECOVERY] Error:', err.message); }
  }

  getTrackForServer(serverId) { return this.serverTracks.get(serverId) || null; }
  getCachedServerData() { return this.cachedServerData; }

  async runUpdateCycle() {
    this.alarmCounter++;
    const cycleId = this.alarmCounter;
    if (this.activeCycleId && this.activeCycleId !== cycleId) console.warn(`[Update] Cycle overlap #${cycleId}`);
    this.activeCycleId = cycleId;
    const ac = new AbortController();
    this.currentAbortController = ac;
    try { setMaxListeners(50, ac.signal); } catch {}
    // Increased from 30s to 45s to handle busy periods with many servers
    const timeout = setTimeout(() => { console.error(`[Update] TIMEOUT #${cycleId}`); ac.abort(); }, 45000);
    try { await this._runUpdateCycleInternal(ac.signal, cycleId); }
    catch (e) { if (e.name !== 'AbortError') console.error('[Update] Error:', e.message); }
    finally { clearTimeout(timeout); if (this.activeCycleId === cycleId) this.activeCycleId = null; this.currentAbortController = null; }
  }

  async _runUpdateCycleInternal(signal, cycleId) {
    const check = () => { if (signal?.aborted) throw new DOMException('Aborted', 'AbortError'); };
    try {
      check();
      const data = await this.fetchServersFromAPI(signal);
      if (!data?.servers) return;
      check();
      const { onlinePlayers } = data;
      const now = Date.now();
      if (onlinePlayers?.length) {
        const toUpdate = [];
        for (const p of onlinePlayers) {
          const guid = p.guid.toUpperCase();
          const cached = this.cachedPlayerStates.get(guid);
          const state = { server: p.currentServer, track: p.currentTrack, bike: p.bikeName, raceNum: p.raceNumber, name: p.displayName };
          const changed = !cached || cached.server !== state.server || cached.track !== state.track || cached.bike !== state.bike || cached.raceNum !== state.raceNum || cached.name !== state.name;
          const updateLastSeen = !cached?.lastSeenUpdate || (now - cached.lastSeenUpdate) >= this.LASTSEEN_UPDATE_INTERVAL;
          if (changed || updateLastSeen) {
            toUpdate.push({ guid, displayName: p.displayName, currentServer: p.currentServer, currentTrack: p.currentTrack, raceNumber: p.raceNumber, bikeName: p.bikeName, lastSeen: now, autoGenerated: true });
            this.cachedPlayerStates.set(guid, { ...state, lastSeenUpdate: updateLastSeen ? now : cached?.lastSeenUpdate });
          }
        }
        for (let i = 0; i < toUpdate.length; i += 25) { check(); await this.db.batchUpsertPlayers(toUpdate.slice(i, i + 25)); }
        if (toUpdate.length) console.log(`[UPDATE] ${toUpdate.length}/${onlinePlayers.length} players`);
      }
      check();
      await this.processServerUpdates(data, signal);
      console.log(`[Cycle #${cycleId}] ${data.servers.length} servers, ${this.serverSessions.size} sessions, ${onlinePlayers?.length || 0} online`);
    } catch (e) { if (e.name === 'AbortError') throw e; console.error('[Update] Error:', e.message); }
  }

  async fetchServersFromAPI(signal) {
    const fetchJson = async (url, opts, ms = 5000) => {
      try {
        if (signal?.aborted) return null;
        const ctrl = new AbortController();
        const tid = setTimeout(() => ctrl.abort(), ms);
        let handler = null;
        if (signal) { handler = () => ctrl.abort(); signal.addEventListener('abort', handler, { once: true }); }
        try {
          const res = await fetch(url, { ...opts, signal: ctrl.signal });
          clearTimeout(tid);
          if (!res.ok) return null;
          return await Promise.race([res.json(), new Promise(r => setTimeout(() => r(null), 3000))]);
        } finally { clearTimeout(tid); if (signal && handler && !signal.aborted) signal.removeEventListener('abort', handler); }
      } catch { if (signal?.aborted) throw new DOMException('Aborted', 'AbortError'); return null; }
    };

    // Always fetch basic server lists (2 requests)
    const [s1, s2] = await Promise.all([
      fetchJson(`${this.env.MXBIKES_API_URL_1}/servers`, { headers: { 'X-API-Key': this.env.MXBIKES_API_KEY_1 } }, 10000),
      fetchJson(`${this.env.MXBIKES_API_URL_2}/servers`, { headers: { 'X-API-Key': this.env.MXBIKES_API_KEY_2 } }, 10000)
    ]);
    const smap = new Map();
    (s1 || []).forEach(s => smap.set(s.id, { server: s, source: 1 }));
    (s2 || []).forEach(s => { if (!smap.has(s.id)) smap.set(s.id, { server: s, source: 2 }); });
    const all = Array.from(smap.values()).map(v => v.server);

    // OPTIMIZATION: Only fetch detailed server data every Nth cycle OR for servers with active sessions
    this.detailedFetchCounter++;
    const shouldFetchAllDetailed = this.detailedFetchCounter >= this.DETAILED_FETCH_INTERVAL;
    if (shouldFetchAllDetailed) this.detailedFetchCounter = 0;

    // Determine which servers need detailed fetch
    const serversNeedingDetail = all.filter(srv => {
      // Always fetch if we should do full refresh
      if (shouldFetchAllDetailed) return true;
      // Always fetch if server has an active session
      if (this.serverSessions.has(srv.id)) return true;
      // Fetch if we don't have cached data
      if (!this.cachedDetailedServers.has(srv.id)) return true;
      // Otherwise use cache
      return false;
    });

    // Only fetch detailed data for servers that need it
    const detailedResults = new Map();
    if (serversNeedingDetail.length > 0) {
      const detailed = await Promise.all(serversNeedingDetail.map(srv => {
        const src = smap.get(srv.id)?.source || 1;
        this.serverToApiMap.set(srv.id, src);
        const url = src === 1 ? this.env.MXBIKES_API_URL_1 : this.env.MXBIKES_API_URL_2;
        const key = src === 1 ? this.env.MXBIKES_API_KEY_1 : this.env.MXBIKES_API_KEY_2;
        return fetchJson(`${url}/servers/${srv.id}`, { headers: { 'X-API-Key': key } }, 2500);
      }));
      serversNeedingDetail.forEach((srv, i) => {
        if (detailed[i]) {
          detailedResults.set(srv.id, detailed[i]);
          this.cachedDetailedServers.set(srv.id, detailed[i]); // Update cache
        }
      });
      if (!shouldFetchAllDetailed) {
        console.log(`[FETCH] Optimized: ${serversNeedingDetail.length}/${all.length} detailed fetches (${all.length - serversNeedingDetail.length} cached)`);
      }
    }

    // Build servers array using fresh + cached data
    const servers = all.map(srv => {
      const d = detailedResults.get(srv.id) || this.cachedDetailedServers.get(srv.id);
      if (d) {
        srv.session = d.session || null;
        srv.riders = d.riders || [];
        srv.session_state = d.session?.session_state;
        srv.session_type = d.session?.session_type;
        if (d.connection_status) srv.liveTimingConnected = d.connection_status.connected;
      }
      srv.apiSource = smap.get(srv.id)?.source || 1;
      srv.liveTimingConnected = srv.liveTimingConnected ?? false;
      srv.remoteAdminConnected = srv.remoteAdminConnected ?? false;
      srv.LiveTimingConnected = srv.liveTimingConnected;
      srv.RemoteAdminConnected = srv.remoteAdminConnected;
      return srv;
    });
    servers.forEach(s => { const t = s.session?.track_name; if (s.id && t) this.serverTracks.set(s.id, t); });
    const players = new Map();
    servers.forEach(s => (s.riders || []).forEach(r => { if (r?.guid && !players.has(r.guid)) players.set(r.guid, { guid: r.guid, displayName: r.name, currentServer: s.name, currentTrack: s.session?.track_name || '', raceNumber: r.race_number, bikeName: r.bike, bestLapTime: r.best_lap?.time || r.best_lap_time || 0 }); }));
    this.cachedServerData = { servers, totalServers: all.length, activeServers: servers.length, activePlayersCount: players.size, onlinePlayers: Array.from(players.values()) };
    this.lastServerDataFetch = Date.now();
    return this.cachedServerData;
  }

  async processServerUpdates(data, signal) {
    const check = () => { if (signal?.aborted) throw new DOMException('Aborted', 'AbortError'); };
    const warmups = [], contacts = [], holeshots = [];
    for (const srv of data.servers) {
      const sid = this.serverSessions.get(srv.id);
      const state = srv.session_state || 'UNKNOWN';
      const phase = (srv.session_type || '').toLowerCase();
      const isWarmup = phase.includes('warmup') || phase.includes('practice');
      if (sid && state === 'INPROGRESS' && isWarmup) {
        const riders = srv.riders || [];
        if (riders.length) {
          const results = riders.filter(r => r.best_lap_time > 0 || r.best_lap?.time > 0)
            .sort((a, b) => (a.best_lap?.time || a.best_lap_time || 999) - (b.best_lap?.time || b.best_lap_time || 999))
            .map((r, i, arr) => {
              const best = r.best_lap?.time || r.best_lap_time || 0;
              const leader = arr[0]?.best_lap?.time || arr[0]?.best_lap_time || 0;
              return { playerGuid: r.guid.toUpperCase(), playerName: r.name, position: i + 1, bestLapTime: best, totalLaps: r.total_laps || 0, raceNumber: r.race_number, bikeName: r.bike_name || r.bike_short_name || '', gap: i > 0 ? best - leader : 0, driverStatus: r.driver_status || null, holeshotTime: r.holeshot_time || null, penalties: r.penalties || [] };
            });
          // ALWAYS store the latest warmup results so we can save them on phase transition
          if (results.length > 0) {
            this.lastWarmupResults.set(sid, results);
          }
          const cached = this.cachedWarmupStates.get(sid);
          let changed = !cached || cached.size !== results.length;
          if (!changed) for (const r of results) { const c = cached.get(r.playerGuid); if (!c || c.pos !== r.position || c.time !== r.bestLapTime || c.laps !== r.totalLaps) { changed = true; break; } }
          if (changed) {
            warmups.push({ sessionId: sid, updates: { warmupResults: results, totalEntries: results.length }, riderCount: results.length });
            const nc = new Map(); results.forEach(r => nc.set(r.playerGuid, { pos: r.position, time: r.bestLapTime, laps: r.totalLaps })); this.cachedWarmupStates.set(sid, nc);
          }
          for (const r of riders) {
            if (r.contacts?.length) {
              if (!this.insertedContacts.has(sid)) this.insertedContacts.set(sid, new Set());
              const ins = this.insertedContacts.get(sid);
              for (const c of r.contacts) {
                const cid = `${c.time}_${c.race_number_1}_${c.race_number_2}`;
                if (!ins.has(cid)) { contacts.push({ sessionId: sid, time: c.time, playerGuid1: r.guid?.toUpperCase(), playerName1: r.name, raceNumber1: c.race_number_1, playerGuid2: null, playerName2: null, raceNumber2: c.race_number_2, relativeImpactVelocity: c.relative_impact_velocity }); ins.add(cid); }
              }
            }
            if (r.holeshot_time > 0) {
              if (!this.insertedHoleshots.has(sid)) this.insertedHoleshots.set(sid, new Set());
              const ins = this.insertedHoleshots.get(sid);
              const guid = r.guid?.toUpperCase();
              if (!ins.has(guid)) { holeshots.push({ sessionId: sid, playerGuid: guid, playerName: r.name, raceNumber: r.race_number, holeshotTime: r.holeshot_time, trackName: srv.session?.track_name || '' }); ins.add(guid); }
            }
          }
        }
      }
    }
    for (let i = 0; i < warmups.length; i += 10) { check(); await this.db.batchUpdateSessions(warmups.slice(i, i + 10)); }
    for (let i = 0; i < contacts.length; i += 10) { check(); await this.db.batchInsertContacts(contacts.slice(i, i + 10)); }
    for (let i = 0; i < holeshots.length; i += 10) { check(); await this.db.batchInsertHoleshots(holeshots.slice(i, i + 10)); }
    check();
    const processed = new Set();
    for (const srv of data.servers) {
      check();
      if (processed.has(srv.id)) continue;
      processed.add(srv.id);
      const state = srv.session_state || 'UNKNOWN';
      const phase = (srv.session_type || '').toLowerCase();
      const prevState = this.previousServerStates.get(srv.id) || 'UNKNOWN';
      const prevPhase = this.serverSessionPhases.get(srv.id) || '';
      if (state !== prevState || (phase !== prevPhase && state === 'INPROGRESS')) {
        await this.handleSessionStateChange(srv, prevState, state, prevPhase, phase, signal);
        this.previousServerStates.set(srv.id, state);
        this.serverSessionPhases.set(srv.id, phase);
      }
    }
  }

  async handleSessionStateChange(srv, prevState, state, prevPhase, phase, signal) {
    const check = () => { if (signal?.aborted) throw new DOMException('Aborted', 'AbortError'); };
    const isWarmup = phase.includes('warmup') || phase.includes('practice');
    const isRace = phase.includes('race') || phase.includes('qualify');
    const wasWarmup = prevPhase.includes('warmup') || prevPhase.includes('practice');
    const wasRace = prevPhase.includes('race') || prevPhase.includes('qualify');
    console.log(`[STATE] ${srv.name}: ${prevPhase}(${prevState}) -> ${phase}(${state})`);
    if (state === 'INPROGRESS' && prevState !== 'INPROGRESS' && !this.serverSessions.has(srv.id)) {
      check();
      const sid = `${srv.id}_${Date.now()}`;
      const sess = srv.session || {};
      this.serverSessions.set(srv.id, sid);
      this.serverSessionPhases.set(srv.id, phase);
      await this.db.createSession({ id: sid, serverId: srv.id, serverName: srv.name, trackName: sess.track_name || '', eventName: sess.event_name || '', sessionType: phase, currentSessionPhase: phase, sessionState: state, weatherConditions: sess.weather_type || '', airTemperature: sess.air_temperature || 20, trackLength: sess.track_length || 0 });
      console.log(`[SESSION] Created ${sid}`);
      return;
    }
    if (wasWarmup && isRace) {
      check();
      const sid = this.serverSessions.get(srv.id);
      if (sid) {
        // CRITICAL: Save the final warmup results before transitioning to race phase
        // This ensures warmup results are always preserved even if we didn't catch the last INPROGRESS state
        const lastWarmup = this.lastWarmupResults.get(sid);
        if (lastWarmup && lastWarmup.length > 0) {
          await this.db.updateSession(sid, { warmupResults: lastWarmup, totalEntries: lastWarmup.length, currentSessionPhase: phase });
          console.log(`[SESSION] ${sid} warmup -> race (saved ${lastWarmup.length} warmup results)`);
        } else {
          await this.db.updateSession(sid, { currentSessionPhase: phase });
          console.log(`[SESSION] ${sid} warmup -> race (no warmup results to save)`);
        }
        this.serverSessionPhases.set(srv.id, phase);
        // Keep lastWarmupResults for reference until session finalization
      }
      return;
    }
    if (state === 'RACEOVER' && isRace) {
      const sid = this.serverSessions.get(srv.id);
      if (!sid || this.mmrSentSessions.has(sid)) return;
      // Mark session as being processed to prevent race conditions with finalization
      this.processingRaceSessions.add(sid);
      this.mmrSentSessions.add(sid);
      // Process race results - await to prevent race condition with finalization
      try {
        await this._processRaceOverAsync(srv, sid);
      } catch (e) {
        console.error(`[RACEOVER] Error ${sid}:`, e.message);
        // Only remove mmrSentSessions marker if we truly failed - allows retry on next cycle
        // But check if we already wrote results to DB first
        const session = await this.db.getSession(sid);
        if (!session?.raceResults?.length) {
          this.mmrSentSessions.delete(sid);
          console.log(`[RACEOVER] ${sid} - will retry on next cycle`);
        } else {
          console.log(`[RACEOVER] ${sid} - results already saved, marking finalized`);
        }
      } finally {
        this.processingRaceSessions.delete(sid);
      }
      return;
    }
    const isUnknown = state === 'UNKNOWN' || state === '--' || !state;
    const isWaiting = state === 'WAITING' || (isUnknown && !phase);
    const shouldFinalize = (prevState === 'COMPLETE' && wasRace) || (wasRace && isWaiting) || (wasRace && isWarmup && state === 'INPROGRESS');
    if (shouldFinalize) {
      check();
      const sid = this.serverSessions.get(srv.id);
      if (!sid) return;
      // CRITICAL: Wait for any in-progress race processing to complete first
      if (this.processingRaceSessions.has(sid)) {
        console.log(`[FINALIZE] ${sid} - waiting for race processing to complete...`);
        // Wait up to 10 seconds for race processing to complete
        const waitStart = Date.now();
        while (this.processingRaceSessions.has(sid) && (Date.now() - waitStart) < 10000) {
          await new Promise(r => setTimeout(r, 250));
        }
        if (this.processingRaceSessions.has(sid)) {
          console.warn(`[FINALIZE] ${sid} - race processing timed out, finalizing anyway`);
        }
      }
      // Check DB state to determine if race was finalized (more reliable than in-memory set)
      const session = await this.db.getSession(sid);
      const hasResults = (session?.raceResults?.length > 0) || this.mmrSentSessions.has(sid);
      await this.db.updateSession(sid, { hasFinished: true, raceFinalized: hasResults, isActive: false, endTime: Date.now() });
      this.serverSessions.delete(srv.id);
      this.serverSessionPhases.delete(srv.id);
      this.mmrSentSessions.delete(sid);
      this.insertedHoleshots.delete(sid);
      this.insertedContacts.delete(sid);
      this.cachedWarmupStates.delete(sid);
      this.lastWarmupResults.delete(sid);  // Clean up warmup results cache
      console.log(`[FINALIZE] ${sid} - raceFinalized: ${hasResults}`);
      if (wasRace && isWarmup && state === 'INPROGRESS') {
        check();
        const newSid = `${srv.id}_${Date.now()}`;
        const sess = srv.session || {};
        this.serverSessions.set(srv.id, newSid);
        this.serverSessionPhases.set(srv.id, phase);
        await this.db.createSession({ id: newSid, serverId: srv.id, serverName: srv.name, trackName: sess.track_name || '', sessionType: phase, currentSessionPhase: phase, sessionState: state });
      }
      return;
    }
    if (state === 'WAITING' && (prevState === 'COMPLETE' || prevState === 'INPROGRESS')) {
      check();
      const sid = this.serverSessions.get(srv.id);
      if (sid) {
        await this.db.updateSession(sid, { hasFinished: true, raceFinalized: false, isActive: false, endTime: Date.now() });
        this.serverSessions.delete(srv.id);
        this.serverSessionPhases.delete(srv.id);
        this.insertedHoleshots.delete(sid);
        this.insertedContacts.delete(sid);
        this.cachedWarmupStates.delete(sid);
      }
    }
  }

  async _processRaceOverAsync(srv, sid) {
    const riders = srv.riders || [];
    if (!riders.length) return;
    try {
      const withLaps = riders.filter(r => r.total_laps > 0);
      if (withLaps.length) {
        const results = withLaps.sort((a, b) => (a.position || 999) - (b.position || 999))
          .map((r, i) => ({ playerGuid: r.guid.toUpperCase(), playerName: r.name, position: i + 1, bestLapTime: r.best_lap?.time || r.best_lap_time || 0, totalLaps: r.total_laps || 0, raceNumber: r.race_number, bikeName: r.bike_name || r.bike_short_name || '', gap: r.gap || 0, driverStatus: r.driver_status || null, holeshotTime: r.holeshot_time || null, contacts: r.contacts || [], invalidLaps: r.invalid_laps || 0, penalties: r.penalties || [] }));
        const mmr = this.db.calculateMMRChanges(results);
        await this.db.batchUpdatePlayerMMR(mmr);
        const players = await this.db.getBatchPlayers(results.map(r => r.playerGuid));
        const resultsWithMMR = results.map(r => {
          const m = mmr.find(c => c.playerGuid === r.playerGuid);
          const p = players.find(x => x?.guid === r.playerGuid);
          return { ...r, mmrChange: m?.mmrChange || 0, srChange: m?.srChange || 0, currentMMR: p?.mmr || 1000 };
        });
        const playerSessions = mmr.map(c => {
          const r = results.find(x => x.playerGuid === c.playerGuid);
          return { playerGuid: c.playerGuid, position: r.position, bestLapTime: r.bestLapTime, totalLaps: r.totalLaps, didFinish: true, mmrChange: c.mmrChange, srChange: c.srChange };
        });
        await this.db.batchAddPlayersToSession(sid, playerSessions);
        await this.db.updateSession(sid, { raceResults: resultsWithMMR, totalEntries: resultsWithMMR.length });
        await this.sendMMRToManagerAPI(srv, resultsWithMMR);
        console.log(`[RACEOVER] ${sid}: Winner ${results[0]?.playerName}`);
      }
    } catch (e) { console.error('[RACEOVER] Error:', e.message); throw e; }
  }

  async sendMMRToManagerAPI(srv, results) {
    const updates = results.map(r => ({ playerGuid: r.playerGuid, playerName: r.playerName, raceNumber: r.raceNumber, mmrChange: r.mmrChange, newMMR: r.currentMMR }));
    const src = this.serverToApiMap.get(srv.id) || 1;
    let url = src === 1 ? this.env.MXBIKES_API_URL_1 : this.env.MXBIKES_API_URL_2;
    let key = src === 1 ? this.env.MXBIKES_API_KEY_1 : this.env.MXBIKES_API_KEY_2;
    const send = (u, k) => Promise.race([fetch(`${u}/servers/${srv.id}/mmr-updates`, { method: 'POST', headers: { 'Content-Type': 'application/json', 'X-API-Key': k }, body: JSON.stringify({ Players: updates }) }), new Promise((_, r) => setTimeout(() => r(new Error('Timeout')), 5000))]);
    try {
      const res = await send(url, key);
      if (res.ok) { const r = await res.json(); console.log(`[MMR] ${r.messagesSent}/${r.totalPlayers} delivered`); }
      else {
        url = src === 1 ? this.env.MXBIKES_API_URL_2 : this.env.MXBIKES_API_URL_1;
        key = src === 1 ? this.env.MXBIKES_API_KEY_2 : this.env.MXBIKES_API_KEY_1;
        const retry = await send(url, key);
        if (retry.ok) console.log('[MMR] Success on retry'); else console.error('[MMR] Failed both APIs');
      }
    } catch (e) { console.error('[MMR] Error:', e.message); }
  }
}
